# AceTime

This library provides date and time classes for the Arduino platform with
support for geographical time zones in the [TZ
database](https://www.iana.org/time-zones). Date and time from one
timezone can be converted to another timezone. The library also provides classes
that build on the built-in `millis()` function to create a "system clock" that
can be synchronized from a more reliable external time source, such as an
[NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) server or a DS3231
RTC chip. This library is meant to be an alternative to the [Arduino
Time](https://github.com/PaulStoffregen/Time) and [Arduino
Timezone](https://github.com/JChristensen/Timezone) libraries.

The library's various date and time classes provide a thin abstraction layer to
make it easier to manipulate date and time fields. For example, the
`dayOfWeek()` returns the day of the week of a date; the `toEpochSeconds()`
returns the number of seconds from a epoch date; the `fromEpochSeconds()`
constructs the date and time fields from the epoch seconds; the
`convertToTimeZone()` converts the datetime from one time zone to another time
zone. The library provides 2 implementations of the IANA TZ Database:
`BasicZoneSpecifier` supports 231 zones which have (relatively) simple time zone
transition rules, and `ExtendedZoneSpecifier` supports all 348 geographical
zones in the database.

Compared to the Arduino Time Library, here are the main differences:
1. AceTime provides more abstraction to make it easier to use. For example, you
can create multiple instances of the system clock if you need to.
1. AceTime supports all 348 geographical zones defined by the TZ Database and
corrects for DST (daylight saving time) transitions automatically.
1. AceTime uses an epoch that starts on 2000-01-01T00:00:00Z, where as Arduino
Time Library uses the Unix epoch of 1970-01-01T00:00:00Z. Using an `int32_t`
(typedef'ed as `ace_time::acetime_t`) to track the number of seconds since the
Epoch, the AceTime library can handle all dates from approximately *1931* to
**2068**.
1. AceTime is **2-5X** faster on an ATmega328P, **3-4X** faster on the ESP8266,
**3-5X** faster on the ESP32, and **7-20X** faster on the ARM (Teensy).
1. AceTime begins the week on a Monday, assigning 1=Monday and 7=Sunday, per ISO
8601 standard, instead of beginning the week on a Sunday.
1. The "system" clock can have both a syncing time source, as well as a backup
time source which can preserve the time after a power failure.

There are roughly 3 bundles of classes provided by the AceTime library,
separated into namespaces:

* date and time classes
    * `ace_time::LocalDate`
    * `ace_time::LocalTime`
    * `ace_time::LocalDateTime`
    * `ace_time::TimeOffset`
    * `ace_time::OffsetDateTime`
    * `ace_time::ZoneSpecifier`
        * `ace_time::ManualZoneSpecifier`
        * `ace_time::BasicZoneSpecifier`
        * `ace_time::ExtendedZoneSpecifier`
    * `ace_time::ZonedDateTime`
    * `ace_time::TimeZone`
    * `ace_time::TimePeriod`
* system clock classes
    * `ace_time::provider::TimeProvider`
        * `ace_time::provider::TimeKeeper`
            * `ace_time::provider::SystemTimeKeeper`
            * `ace_time::provider::DS3231TimeKeeper`
        * `ace_time::provider::NtpTimeProvider`
    * `ace_time::provider::SystemTimeHeartbeatCoroutine`
    * `ace_time::provider::SystemTimeHeartbeatLoop`
    * `ace_time::provider::SystemTimeSyncCoroutine`
    * `ace_time::provider::SystemTimeSyncLoop`
* TZ Database zone files
    * C++ files generated by a code-generator from the TZ Database zone files
    * `ace_time::zonedb` (231 zones from TZ Database)
        * Used by `BasicZoneSpecifier`
        * `zonedb::kZoneAfrica_Abidjan`
        * `zonedb::kZoneAfrica_Accra`
        * (...227 other zones...)
        * `zonedb::kZonePacific_Wake`
        * `zonedb::kZonePacific_Wallis`
    * `ace_time::zonedbx` (all 348 geographical zones from TZ Database)
        * Used by `ExtendedZoneSpecifier`
        * `zonedbx::kZoneAfrica_Abidjan`
        * `zonedbx::kZoneAfrica_Accra`
        * (...344 other zones...)
        * `zonedbx::kZonePacific_Wake`
        * `zonedbx::kZonePacific_Wallis`

The AceTime library is inspired by and borrows from:
* [Java 11 Time](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/package-summary.html)
* [Micro Time Zone](https://github.com/evq/utz)
* [Arduino Timezone](https://github.com/JChristensen/Timezone)
* [Arduino Time](https://github.com/PaulStoffregen/Time)
* [Joda-Time](https://www.joda.org/joda-time/)
* [Noda Time](https://nodatime.org/)
* [Python datetime](https://docs.python.org/3/library/datetime.html)

Version: 0.1 (2019-06-15)

## HelloTime

Here is a simple program (see [examples/HelloTime](examples/HelloTime)) which
demonstrates how to create and manipulate date and times in different time
zones:

```C++
#include <AceTime.h>

using namespace ace_time;

static BasicZoneSpecifier pacificSpec(&zonedb::kZoneAmerica_Los_Angeles);
static BasicZoneSpecifier easternSpec(&zonedb::kZoneAmerica_New_York);
static ExtendedZoneSpecifier turkeySpec(&zonedbx::kZoneEurope_Istanbul);

void setup() {
  delay(1000);
  Serial.begin(115200); // ESP8266 default of 74880 not supported on Linux
  while (!Serial); // Wait until Serial is ready - Leonardo/Micro

  auto pacificTz = TimeZone::forZoneSpecifier(&pacificSpec);
  auto easternTz = TimeZone::forZoneSpecifier(&easternSpec);
  auto turkeyTz = TimeZone::forZoneSpecifier(&turkeySpec);

  // Create from components
  auto pacificTime = ZonedDateTime::forComponents(
      2019, 6, 1, 11, 38, 0, pacificTz);

  Serial.print(F("America/Los_Angeles: "));
  pacificTime.printTo(Serial);
  Serial.println();

  Serial.print(F("Epoch Seconds: "));
  acetime_t epochSeconds = pacificTime.toEpochSeconds();
  Serial.println(epochSeconds);

  Serial.print(F("Unix Seconds: "));
  acetime_t unixSeconds = pacificTime.toUnixSeconds();
  Serial.println(unixSeconds);

  // Create from epoch seconds
  auto easternTime = ZonedDateTime::forEpochSeconds(epochSeconds, easternTz);

  Serial.print(F("America/New_York: "));
  easternTime.printTo(Serial);
  Serial.println();

  // Create by conversion to time zone
  auto turkeyTime = easternTime.convertToTimeZone(turkeyTz);

  Serial.print(F("Europe/Istanbul: "));
  turkeyTime.printTo(Serial);
  Serial.println();

  Serial.print(F("pacific.compareTo(turkey): "));
  Serial.println(pacificTime.compareTo(turkeyTime));

  Serial.print(F("pacific == turkey: "));
  Serial.println((pacificTime == turkeyTime) ? "true" : "false");
}

void loop() {
}
```

Running this should produce the following on the Serial port:
```
 America/Los_Angeles: 2019-06-01T11:38:00-07:00 Saturday [America/Los_Angeles]
 Epoch Seconds: 612729480
 Unix Seconds: 1559414280
 America/New_York: 2019-06-01T14:38:00-04:00 Saturday [America/New_York]
 Europe/Istanbul: 2019-06-01T21:38:00+03:00 Saturday [Europe/Istanbul]
 pacific.compareTo(turkey): 0
 pacific == turkey: false
```

## Installation

The latest stable release will soon be available in the Arduino IDE Library
Manager. Search for "AceTime". Click Install.

The development version can be installed by cloning the
[GitHub repository](https://github.com/bxparks/AceTime), checking out the
`develop` branch, then manually copying over the contents to the `./libraries`
directory used by the Arduino IDE. (The result is a directory named
`./libraries/AceTime`.) The `master` branch contains the stable release.

### Source Code

The source files are organized as follows:
* `src/AceTime.h` - main header file
* `src/ace_time/` - date and time files
* `src/ace_time/common/` - internal shared files
* `src/ace_time/hw/` - thin hardware abstraction layer
* `src/ace_time/provider/` - providers from RTC or NTP sources
* `src/ace_time/testing/` - files used in unit tests
* `src/ace_time/zonedb/` - files generated from TZ Database for `BasicZoneSpecifier`
* `src/ace_time/zonedbx/` - files generated from TZ Database for `ExtendedZoneSpecifier`
* `tests/` - unit tests using [AUnit](https://github.com/bxparks/AUnit)
* `examples/` - example programs
* `tools/` - scripts to parse the TZ Database files

### Dependencies

The vast majority of the AceTime library has no dependency any other external
libraries. There is an optional dependency to
[AceRoutine](https://github.com/bxparks/AceRoutine) if you want to use the
`SystemTimeSyncCoroutine` and `SystemTimeHeartbeatCoroutine` classes for
automatic syncing and freshening. (This is recommended but not strictly
necessary). The `ace_time/hw/CrcEeprom.h` class has a dependency to the FastCRC
library but the `CrcEeprom.h` file is not included by in the `AceTime.h` main
header file, so you should not need FastCRC to compile AceTime. (The
`CrcEeprom.h` header file does not strictly belong in the AceTime library but
many of my "clock" projects that use the AceTime library also use the
`CrcEeprom` class, so this is a convenient place to keep it.)

Various programs in the `examples/` directory have one or more of the following
external dependencies:

* [AceRoutine](https://github.com/bxparks/AceRoutine)
* [AceButton](https://github.com/bxparks/AceButton)
* [FastCRC](https://github.com/FrankBoesing/FastCRC)
* [SSD1306Ascii](https://github.com/greiman/SSD1306Ascii)
* [Arduino Time Lib](https://github.com/PaulStoffregen/Time)
* [Arduino Timezone](https://github.com/JChristensen/Timezone)

### Docs

The [docs/](docs/) directory contains the
[Doxygen docs on GitHub Pages](https://bxparks.github.io/AceTime/html).

### Examples

The following example sketches are provided:

* [HelloTime](examples/HelloTime/)
    * demo program of various date and time classes
* [CommandLineClock](examples/CommandLineClock/)
    * a clock with a DS3231 RTC chip, an NTP client, and using the serial port
      for receiving commands and printing results, useful for debugging
* [OledClock](examples/OledClock/)
    * a digital clock using a DS3231 RTC chip, an NTP client, 2 buttons, and an
      SSD1306 OLED display
* [WorldClock](examples/WorldClock/)
    * a clock with 3 OLED screens showing the time at 3 different time zones
* [AutoBenchmark](examples/AutoBenchmark/)
    * perform CPU and memory benchmarking of various methods and print a report
* [ComparisonBenchmark](examples/ComparisonBenchmark/)
    * compare AceTime with
    [Arduino Time Lib](https://github.com/PaulStoffregen/Time)
* [CrcEepromDemo](examples/CrcEepromDemo/)
    * a program that verifies the `CrcEeprom` class

## Usage

### Headers and Namespaces

Only a single header file `AceTime.h` is required to use this library.
To prevent name clashes with other libraries that the calling code may use, all
classes are separated into a number of namespaces. They are related in the
following way, where the arrow means "depends on":

```
ace_time::provider
      |      \
      |       \
      |        v
      |        ace_time
      |         |\     \
      |         | \     v
      |         |  \    ace_time::zonedb
      |         |   \   ace_time::zonedbx
      |         |    \     |
      v         |     v    v
ace_time::hw    |     ace_time::basic
          \     |     ace_time::extended
           \    |     /
            \   |    /
             v  v   v
           ace_time::common
```

To use the classes without prepending the namespace prefixes, use one or more of
the following `using` one or more of the following directives:

```C++
#include <AceTime.h>
using namespace ace_time;
using namespace ace_time::provider;
using namespace ace_time::common;
using namespace ace_time::zonedb;
using namespace ace_time::zonedbx;
...
```

### Epoch Seconds Typedef

One of the fundamental types in AceTime is the `acetime_t` defined as:
```C++
typedef int32_t acetime_t;
```
This represents the number of seconds since the Epoch. In AceTime, the Epoch is
defined to be 2000-01-01 00:00:00 UTC time. In contrast, Unix Epoch is defined
to be 1970-01-01 00:00:00 UTC.

### LocalDate and LocalTime

The `LocalDate` and `LocalTime` represent date and time components, without
reference to a particular time zone. They are not expected to be commonly used
by the end-users, but they are available if needed.

```C++
#include <AceTime.h>
using namespace ace_time;
...

// LocalDate that represents 2019-05-20
LocalDate localDate = LocalDate::forComponents(2019, 5, 20);

// LocalTime that represents 13:00:00
LocalTime localTime = LocalTime::forComponents(13, 0, 0);
```

You can ask the `LocalDate` to determine its day of the week, which returns
an integer where `1=Monday` and `7=Sunday` per
[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601):
```C++
uint8_t dayOfWeek = localDate.dayOfWeek();
```
For convenience, the following constants are defined in `LocalDate`:
```C++
const uint8_t LocalDate::kMonday = 1;
const uint8_t LocalDate::kTuesday = 2;
const uint8_t LocalDate::kWednesday = 3;
const uint8_t LocalDate::kThursday = 4;
const uint8_t LocalDate::kFriday = 5;
const uint8_t LocalDate::kSaturday = 6;
const uint8_t LocalDate::kSunday = 7;
```

### Date Strings

To convert the `dayOfweek()` numerical code to a human-readable string for
debugging or display, we can use the `common::DateStrings` class:

```C++
#include <AceTime.h>
using namespace ace_time;
using common::DateStrings;
...

LocalDate localDate = LocalDate::forComponents(2019, 5, 20);
uint8_t dayOfWeek = localDate.dayOfWeek();
Serial.println(DateStrings().weekDayLongString(dayOfWeek));
Serial.println(DateStrings().weekDayShortString(dayOfWeek));
```
The `DateStrings` class is inside the `ace_time::common` namespace, so you need
to prefix it with `common::`. The `weekDayShortString()` method returns the
first 3 characters of the week day (i.e. "Mon", "Tue", "Wed", "Thu",
"Fri", "Sat", "Sun").

Similarly the `LocalDate::month()` method returns an integer code where
`1=January` and `12=December`. This integer code can be translated into English
strings using:

```C++
uint8_t month = localDate.month();
Serial.println(DateStrings().monthLongString(month));
Serial.println(DateStrings().monthShortString(month));
```
The `monthShortString()` method returns the first 3 characters of the month
(i.e. "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct",
"Nov", "Dec").

**Caution**: The `DateStrings` object uses a temporary internal buffer to hold
the generated human-readable strings. It is meant to be created temporarily on
the stack, used to extract the appropriate string, then reclaimed from the
stack. It is not meant to be created and persisted for a long period of time,
unless you are sure that nothing else will reuse the internal buffer between
calls.

**Caveat**: The `common::DateString` class supports only the English language.
If you need to convert to another language, you need to write the conversion
class yourself. See the implementation details of the `DateStrings` class to see
how that can be done.

### LocalDateTime

A `LocalDateTime` object holds both the date and time components
(year, month, day, hour, minute, second). Internally, it is implemented as a
combination of `LocalDate` and `LocalTime` and supports essentially all
operations on those classes. It does *not* support the notion of timezone.

```C++
LocalDateTime localDateTime;

// 2018-08-30T06:45:01-08:00
localDateTime = LocalDateTime::forComponents(2018, 8, 30, 6, 45, 1);
```

Once a `LocalDateTime` object is created you can access the individual date/time
components using the accessor methods:
```C++
int16_t year = localDateTime.year(); // 1872 - 2127
uint8_t month = localDateTime.month(); // 1 - 12
uint8_t day = localDateTime.day(); // 1 - 31
uint8_t hour = localDateTime.hour(); // 0 - 23
uint8_t minute = localDateTime.minute(); // 0 - 59
uint8_t second = localDateTime.second(); // 0 - 59
uint8_t dayOfWeek = localDateTime.dayOfWeek(); // 1=Monday, 7=Sunday
```

We can extract the number of seconds since AceTime Epoch
(2000-01-01T00:00:00Z) using the `toEpochSeconds()` method:
```C++
acetime_t epoch_seconds = localDateTime.toEpochSeconds();
```

We can go the other way and create a `LocalDateTime` from the Epoch Seconds:
```C++
LocalDateTime localDateTime = LocalDateTime::forEpochSeconds(1514764800L);
localDateTime.printTo(Serial); // prints "2018-01-01T00:00:00"
```
### TimeOffset

A `TimeOffset` class represents an amount of time shift from a reference point.
Often the reference is the UTC time and this class represents the amount of time
shift from UTC. Currently (year 2019) every time zone in the world is shifted
from UTC by a multiple of 15 minutes (e.g. -03:30 or +01:00). `TimeOffset` is a
thin wrapper around a single 8-bit signed integer which can encode integers from
[-128, 127]. Internally -128 is used to indicate an error condition, so we can
represent a UTC shift of from -31:45 to +31:45 hours, which is more than enough
to encode all UTC offsets currently in use.

A `TimeOffset` can be created using a number of factory methods:
```C++
TimeOffset offset = TimeOffset::forHour(-8); // -08:00
TimeOffset offset = TimeOffset::forHourMinute(-2, -30); // -02:30
TimeOffset offset = TimeOffset::forMinutes(135); // +02:15
```

If the time offset is negative, then both the hour and minute components of
`forHourMinute()` must be negative. (The duplication of the negative sign allows
the creation of UTC-00:15, UTC-00:30 and UTC-00:45.)

A `TimeOffset` instance can be converted into different formats:
```C++
int32_t seconds = offset.toSeconds();
int16_t minutes = offset.toMinutes();

int8_t hour;
int8_t minute;
offset.toHourMinute(&hour, &minute);
```

When a method in some class (e.g. `OffsetDateTime` or `ZonedDateTime` below)
returns a `TimeOffset`, it is useful to indicate an error condition by returning
the special value created by the factory method `TimeOffset::forError()`. This
special error marker has the property that `TimeOffset::isError()` returns
`true`. Internally, this is an instance whose internal integer code is -128.

The convenience method `TimeOffset::isZero()` returns `true` if the offset has a
zero offset. This is often used to determine if a timezone is currently
observing Daylight Saving Time (DST).

### OffsetDateTime

An `OffsetDateTime` is an object that can represent a date&time which is
offset from the UTC time zone by a fixed amount. Internally the `OffsetDateTime`
is a aggregation of `LocalDateTime` and `TimeOffset`. We can create the object
using the `forComponents()` method:
```C++
// 2018-01-01 00:00:00+00:15
OffsetDateTime offsetDateTime = OffsetDateTime::forComponents(
    2018, 1, 1, 0, 0, 0, TimeOffset::forHourMinute(0, 15));
acetime_t epochDays = offsetDateTime.toEpochDays();
acetime_t epochSeconds = offsetDateTime.toEpochSeconds();

offsetDateTime.printTo(Serial); // prints "2018-01-01 00:00:00+00:15"
Serial.println(epochDays); // prints 6574
Serial.println(epochSeconds); // prints 568079100
```

We can create an `OffsetDateTime` object from the seconds from Epoch using
the `forEpochSeconds()` method:
```C++
OffsetDateTime offsetDateTime = OffsetDateTime::forEpochSeconds(
    568079100, TimeOffset::forHourMinute(0, 15));
```

A value of `LocalDate::kInvalidEpochSeconds` is used internally as an ERROR
marker so it is not possible to create a `LocalDateTime` or an `OffsetDateTime`
object with this value. In other words both of these:
```C++
LocalDateTime::forEpochSeconds(LocalDate::kInvalidEpochSeconds);
OffsetDateTime::forEpochSeconds(LocalDate::kInvalidEpochSeconds);
```
creates an object which returns `true` for the `isError()` method.

### TimeZone

A "time zone" is often used colloquially to mean 2 different things:
* A time which is offset from the UTC time by a fixed amount, or
* A physical (or conceptual) region whose local time is offset
from the UTC time using various transition rules.

Both meanings of "time zone" are supported by the `TimeZone` class using
4 different types as follows:

* `TimeZone::kTypeFixed`: a fixed offset from UTC
* `TimeZone::kTypeManual` with `ManualZoneSpecifier`: A user-defined
fixed offset with a user-defined DST flag
* `TimeZone::kTypeBasic` with `BasicZoneSpecifier`: zones which can
be encoded with (relatively) simple rules from the TZ Database
* `TimeZone::kTypeExtended` with `ExtendedZoneSpecifier`:  all zones in
the TZ Database

The subsections below show how these can be constructed.

The `TimeZone` class exposes the following methods:
```C++
class TimeZone {
  public:
    TimeOffset getUtcOffset(acetime_t epochSeconds) const;
    TimeOffset getDeltaOffset(acetime_t epochSeconds) const;
    TimeOffset getUtcOffsetForDateTime(const LocalDateTime& ldt) const;
    void printAbbrevTo(Print& printer, acetime_t epochSeconds) const;
    ...
};
```

The `getUtcOffset(epochSeconds)` returns the total `TimeOffset` (including any
DST offset) at the given `epochSeconds`. The `getDeltaOffset()` returns only the
additional DST offset; if DST is not in effect at the given `epochSeconds`, this
returns a `TimeOffset` whose `isZero()` returns true.

The `getUtcOffsetForDateTime()` method returns the best guess of the total UTC
offset at the given local date time. The reaon that this is a best guess is
because the local date time is sometime ambiguious during a DST transition. For
example, if the local clock shifts from 01:00 to 02:00 at the start of summer,
then the time of 01:30 does not exist. If the `getUtcOffsetForDateTime()` method
is given a non-existing time, it makes an educated guess at what the user meant.
Additionally, when the local time transitions from 02:00 to 01:00 in the autumn,
a given local time such as 01:30 occurs twice. If the
`getUtcOffsetForDateTime()` method is given a time of 01:30, it will arbitrarily
decide which offset to return.

The `printAbbrevTo(epochSeconds)` method prints the human-readable timezone
abbreviation used at the given `epochSeconds`.

#### Fixed TimeZone (kTypeFixed)

The default constructor creates a fixed `TimeZone` in UTC time zone with no
offset:
```C++
TimeZone tz; // UTC+00:00
```

To create `TimeZone` instances with other offsets, use one of the factory
methods:
```C++
TimeZone tz = TimeZone::forTimeOffset(TimeOffset::forHour(-8)); // UTC-08:00
TimeZone tz = TimeZone::forTimeOffset(TimeOffset::forHourMinute(-4, -30)); // UTC-04:30
```

#### ManualZoneSpecifier (kTypeManual)

A `ManualZoneSpecifier` describes a time zone which allows the user to set
the UTC offset, and to select whether or not the DST offset is being observed.
The constructor looks like this:
```C++
ManualZoneSpecifier(
    TimeOffset stdOffset = TimeOffset(),
    bool isDst = false,
    const char* stdAbbrev = "",
    const char* dstAbbrev = "",
    TimeOffset deltaOffset = TimeOffset::forHour(1));
```
All the parameters are theoretically optional, but most applications will
set at least the `stdOffset` parameter:

* `stdOffset`: the standard time UTC offset (default: 00:00)
* `isDst`: whether the DST is being observed (default: false)
* `stdAbbrev`: the abbreviation during standard time (default: "")
* `dstAbbrev`: the abbreviation during DST (default: "")
* `deltaOffset`: the time shift during DST (default: +01:00)

When `ManualZoneSpecifier::getUtcOffset()` is called, it will normally return
the value of `stdOffset`. However, if the user sets the `isDst` flag to `true`
using `ManualZoneSpecifier::isDst(true)`, then `getUtcOffset()` will return
`stdOffset + deltaOffset`.

The `ManualZoneSpecifier` is expected to be created once at the beginning of
the application. The `TimeZone` object can be created on demand by pointing it
to the `ManualZoneSpecifier` instance. For example, the following creates a
`TimeZone` set to be UTC-08:00 normally, but can change to UTC-07:00 when the
`ManualZoneSpecifier::isDst(true)` is called:

```C++
ManualZoneSpecifier zoneSpecifier(TimeOffset::forHour(-8), false, "PST", "PDT");

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);
  TimeOffset offset = tz.getUtcOffset(0); // returns -08:00
  tz.isDst(true);
  offset = tz.getUtcOffset(0); // returns -07:00
  ...
}
```

The `TimeZone::isDst()` and `TimeZone::isDst(bool)` methods are convenience
methods that work only if the `TimeZone` instance refers to a
`ManualZoneSpecifier`. They simply call the underying `ManualZoneSpecifier`. If
the underlying `ZoneSpecifier` is a different type, the `TimeZone::isDst()` does
nothing.

#### BasicZoneSpecifier (kTypeBasic)

The `BasicZoneSpecifier` represents a time zone defined by the TZ Database. The
constructor accepts a pointer to a `basic::ZoneInfo`:
```C++
BasicZoneSpecifier(const basic::ZoneInfo* zoneInfo);
```

The supported `basic::ZoneInfo` data objects are contained in
[zonedb/zone_info.h](src/ace_time/zonedb/zone_infos.h) which was generated by
a script using the TZ Database. This header file is already included in
`<AceTime.h>`. As of version 2019a of the database, it contains 231 zones whose
time change rules are simple enough to be supported by `BasicZoneSpecifier`. The
bottom of the `zone_infos.h` header file lists 128 zones whose zone rules are
too complicated for `BasicZoneSpecifier`. Some examples of `ZoneInfo` entries
supported by `zonedb` are:

* `zonedb::kZoneAmerica_Los_Angeles`
* `zonedb::kZoneAmerica_New_York`
* `zonedb::kZoneEurope_London`
* ...


The following example creates a `TimeZone` using a `BasicZoneSpecifier` which
describes `America/Los_Angeles`:

```C++
#include <AceTime.h>
using namespace ace_time;
...

BasicZoneSpecifier zoneSpecifier(&zonedb::kZoneAmerica_Los_Angeles);

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);

  // 2018-03-11T01:59:59-08:00 was still in STD time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 1, 59, 59,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -08:00
  }

  // 2018-03-11T02:00:00-08:00 was in DST time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 2, 0, 0,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -07:00
  }
  ...
}
```

#### ExtendedZoneSpecifier (kTypeExtended)

The `ExtendedZoneSpecifier` is very similar to `BasicZoneSpecifier` except that
it supports (almost) all zones in the TZ Database instead of a subset. The
supported zones are given in
[zonedbx/zone_infos.h](src/ace_time/zonedbx/zone_infos.h).
As of version 2019a of TZ Database, there are 348 supported time zones. We`
ignore the 11 zones are those whose zone names do **not** contain a `/`
character (CET, CST6CDT, EET, EST, EST5EDT, HST, MET, MST, MST7MDT, PST8PDT,
WET) because they don't correspond to an actual geographical zone.

The zone infos which can be used by `ExtendedZoneSpecifier` are in the
`zonedbx::` namespace instead of the `zonedb::` namespace. Some examples of the
zone infos are:
* `zonedbx::kZoneAmerica_Los_Angeles`
* `zonedbx::kZoneAmerica_Indiana_Indianapolis`
* `zonedbx::kZoneAmerica_New_York`
* `zonedbx::kZoneEurope_London`
* `zonedbx::kZoneAfrica_Casablanca`
* ...

The usage is the same as `BasicZoneSpecifier`:
```C++
ExtendedZoneSpecifier zoneSpecifier(&zonedbx::kZoneAmerica_Los_Angeles);

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);

  // 2018-03-11T01:59:59-08:00 was still in STD time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 1, 59, 59,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -08:00
  }

  // 2018-03-11T02:00:00-08:00 was in DST time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 2, 0, 0,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -07:00
  }
  ...
}
```

The advantage of `ExtendedZoneSpecifier` over `BasicZoneSpecifier` is that
`ExtendedZoneSpecifier` supports all (actual geographical) time zones in the TZ
Database. The cost is that it consumes 5 times more memory and is slower. If
`BasicZoneSpecifier` supports the zone that you want using the zone files in the
`zonedb::` namespace, you should normally use that instead of
`ExtendedZoneSpecifier`. The one other advatnage of `ExtendedZoneSpecifier`
over `BasicZoneSpecifier` is that `ExtendedZoneSpecifier::forComponents()`
is more accurate than `BasicZoneSpecifier::forComponents()` because the
`zonedbx::` data files contain transition information which are missing in the
`zonedb::` data files due to space constraints.

### ZonedDateTime

A `ZonedDateTime` is a `LocalDateTime` associated with a given `TimeZone`. This
is analogous to an`OffsetDateTime` being a `LocalDateTime` associated with a
`TimeOffset`. All 4 types of `TimeZone` are supported, the `ZonedDateTime`
class itself does not care which one is used.

Here is an example of how to create one and extract the epoch seconds:

```C++
BasicZoneSpecifier zoneSpecifier(&zonedb::kZoneAmerica_Los_Angeles);

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);

  // 2018-01-01 00:00:00+00:15
  ZonedDateTime zonedDateTime = ZonedDateTime::forComponents(
      2018, 1, 1, 0, 0, 0, tz);
  acetime_t epochDays = zonedDateTime.toEpochDays();
  acetime_t epochSeconds = zonedDateTime.toEpochSeconds();

  zonedDateTime.printTo(Serial); // prints "2018-01-01 00:00:00-08:00"
  Serial.println(epochDays); // prints 6574 [TODO: Check]
  Serial.println(epochSeconds); // prints 568079100 [TODO: Check]
  ...
}
```

#### Conversion to Other Time Zones

You can convert a given `ZonedDateTime` object into a representation in a
different time zone using the `DateTime::convertToTimeZone()` method:
```C++
BasicZoneSpecifier zspecLosAngeles(&zonedb::kZoneAmerica_Los_Angeles);
BasicZoneSpecifier zspecZurich(&zonedb::kZoneEurope_Zurich);

void someFunction() {
  ...
  TimeZone tzLosAngeles = TimeZone::forZoneSpecifier(&zspecLosAngeles);
  TimeZone tzZurich = TimeZone::forZoneSpecifier(&zspecZurich);

  // Europe/Zurich, 2018-01-01T09:20:00+01:00
  ZonedDateTime zurichTime = ZonedDateTime::forComponents(
      2018, 1, 1, 9, 20, 0, tzZurich);

  // Convert to America/Los_Angeles, 2018-01-01T01:20:00-08:00
  ZonedDateTime losAngelesTime = zurichTime.convertToTimeZone(tzLosAngeles);
  ...
}
```

The two `ZonedDateTime` objects will return the same value for `epochSeconds()`
because that is not affected by the time zone. However, the various date time
components (year, month, day, hour, minute, seconds) will be different.

### TimePeriod

The `TimePeriod` class can be used to represents a difference between two
`XxxDateTime` objects, if the difference is not too large. Internally, it is
implemented as 3 unsigned `uint8_t` integers representing the hour, minute and
seconds. There is a 4th signed `int8_t` integer that holds the sign (-1 or +1)
of the time period. The largest (or smallest) time period that can be
represented by this class is +/- 255h59m59s, corresponding to +/- 921599
seconds.

This class is intended to be used when the difference between 2 dates need to be
presented to the user broken down into hours, minutes and seconds. For example,
we can print out a count down to a target `ZonedDateTime` from the current
`ZonedDateTime` like this:
```C++
ZonedDateTime currentDate = ...;
ZonedDateTime targetDate = ...;
acetime_t diffSeconds =
    targetDate.toEpochSeconds() - currentDate.toEpochSeconds();
TimePeriod timePeriod(diffSeconds);
timePeriod.printTo(Serial)
```

### TimeProviders and TimeKeepers

The `acetime::provider` namespace contains classes that implement various clocks
which track the number of seconds (`acetime_t`) since the AceTime epoch
(2000-01-01T00:00:00Z).

The `TimeProvider` interface implements the `TimeProvider::getNow()` method
which returns an `acetime_t`. The `TimeKeeper` interface implements the
`TimeKeeper::setNow(acetime_t)` method which sets the current time. A
`TimeKeeper` is a subclass of `TimeProvider`.

The `acetime_t` value can be converted into the desired time zone using the
`ZonedDateTime` and `TimeZone` classes desribed in the previous section. For
example, to print the current time in UTC, use something like:
```C++
TimeProvider timeProvider = ...;
acetime_t nowSeconds = timeProvider.getNow();
LocalDateTime now = LocalDateTime::forEpochSeconds(nowSeconds);
now.printTo(Serial);
```

Various implementation class of `TimeProvider` and `TimeKeeper` are described in
more detail the following subsections. All of these classes are in the
`ace_time::provider` namespace.

#### NTP Time Provider

The `NtpTimeProvider` is available on the ESP8266 and ESP32 which have builtin
WiFi capability. (I have not tested the code on the Arduino WiFi shield
because I don't have that hardware.) This class uses an NTP client to fetch the
current time from the specified NTP server. The constructor takes 3 parameters
which have default values so they are optional.

You need to call the `setup()` with the `ssid` and `password` of the WiFi
connection. The method will time out after 5 seconds if the connection cannot
be established.

```C++
#include <AceTime.h>
using namespace ace_time;
using namespace ace_time::provider;

const char SSID[] = ...; // Warning: don't store SSID in GitHub
const char PASSWORD[] = ...; // Warning: don't store passwd in GitHub

NtpTimeProvider ntpTimeProvider;

void setup() {
  Serial.begin(115200);
  while(!Serial); // needed for Leonardo/Micro
  ...
  ntpTimeProvider.setup(SSID, PASSWORD);
  if (ntpTimeProvider.isSetup()) {
    Serial.println("WiFi connection failed... try again.");
  }
}

// Print the NTP time every 10 seconds, in UTC-08:00 time zone.
void loop() {
  acetime_t nowSeconds = ntpTimeProvider.getNow();
  OffsetDateTime odt = OffsetDateTime::forEpochSeconds(
      nowSeconds, TimeOffset::forHour(-8)); // convert UTC to UTC-08:00
  odt.printTo(Serial);
  delay(10000); // wait 10 seconds
}
```

**Security Warning**: You should avoid committing your SSID and PASSWORD into a
public repository like GitHub because they will become public to anyone. Even if
you delete the commit, they can be retrieved from the git history.

#### DS3231 Time Keeper

The `DS3231TimeKeeper` is the class describing the DS3231 RTC chip. It contains
an internal 32kHz, temperature compensated osciallator that counts time in 1
second steps. It is often connected to a battery or a supercapacitor to survive
power failures. The DS3231 chip stores the time broken down by various date and
time components (i.e. year, month, day, hour, minute, seconds). It contains
internal logic that knows about the number of days in an month, and leap years.
It supports dates from 2000 to 2099. It does *not* contain the concept of a time
zone. Therefore, The `DS3231TimeKeeper` assumes that the date/time components
stored on the chip is in **UTC** time.

The `DS3231TimeKeeper::getNow()` returns the number of seconds since
AceTime Epoch by converting the UTC date and time components to `acetime_t`
(using `LocalDatetime` internally). Users can convert the epoch seconds
into either an `OffsetDateTime` or a `ZonedDateTime` as needed.

The `DS3231TimeKeeper::setup()` should be called from the global `setup()`
function to initialize the object. Here is a sample that

```C++
#include <AceTime.h>
using namespace ace_time;
using namespace ace_time::provider;

DS3231TimeKeeper dsTimeKeeper;
...
void setup() {
  Serial.begin(115200);
  while(!Serial); // needed for Leonardo/Micro
  ...
  dsTimeKeeper.setup();
  dsTimeKeeper.setNow(0); // 2000-01-01T00:00:00Z
}

void loop() {
  acetime_t nowSeconds = dsTimeKeeper.getNow();
  OffsetDateTime odt = OffsetDateTime::forEpochSeconds(
      nowSeconds, TimeOffset::forHour(-8)); // convert UTC to UTC-08:00
  odt.printTo(Serial);
  delay(10000); // wait 10 seconds
}
```

#### System Time Keeper

The `SystemTimeKeeper` is a special `TimeKeeper` that uses the Arduino built-in
`millis()` method as the source of its time. The biggest advantage of
`SystemTimeKeeper` is that its `getNow()` has very little overhead _(TBD: insert
benchmark)_ so it can be called as frequently as needed. The `getNow()` method
of other `TimeProviders` can consume a significant amount of time. For example,
the `DS3231TimeKeeper` must talk to the DS3231 RTC chip over an I2C bus. Even
worse, the `NtpTimeProvider` must the talk to the NTP server over the network
which can be unpredictably slow.

Unfortunately, the `millis()` internal clock of most (all?) Arduino boards is
not very accurate and unsuitable for implementing an accurate clock. Therefore,
the `SystemTimeKeeper` provides a mechanism to synchronize its clock to an
external (and presumably more accurate clock) `TimeProvider`.

The `SystemTimeKeeper` also provides a way to save the current time to a
`backupTimeKeeper` (e.g. the `DS3231TimeKeeper` using the DS3231 chip with
battery backup). When the `SystemTimeKeeper` starts up, it will read the backup
`TimeKeeper` and set the current time. Then it can synchronize with an external
clock source (e.g. the `NtpTimeProvider`). The time is saved to the backup time
keeper whenever the `SystemTimeKeeper` is synced with the external time
provider.

Here is how to set up the `SystemTimeKeeper`:
```C++
#include <AceTime.h>
using namespace ace_time;
using namespace ace_time::provider;

DS3231TimeKeeper dsTimeKeeper;
NtpTimeProvider ntpTimeProvider(SSID, PASSWORD);
SystemTimeKeeper systemTimeKeeper(
  &ntpTimeProvider /*sync*/, &dsTimeKeeper /*backup*/);
...

void setup() {
  Serial.begin(115200);
  while(!Serial); // needed for Leonardo/Micro
  ...
  dsTimeKeeper.setup();
  ntpTimeProvider.setup();
  systemTimeKeeper.setup();
}

void loop() {
  acetime_t nowSeconds = systemTimeKeeper.getNow();
  OffsetDateTime odt = OffsetDateTime::forEpochSeconds(
      nowSeconds, TimeOffset::forHour(-8)); // convert UTC to UTC-08:00
  odt.printTo(Serial);
  delay(10000); // wait 10 seconds
}
```

If you wanted to use the `DS3231TimeKeeper` as *both* the backup and sync
time sources, then the setup would something like this:
```C++
DS3231TimeKeeper dsTimeKeeper;
SystemTimeKeeper systemTimeKeeper(
    &dsTimeKeeper /*sync*/, &dsTimeKeeper /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  systemTimeKeeper.setup();
  ...
}
```

You could also choose not to have either the backup or sync time sources, in
which case you can give `nullptr` as the correspond argument. For example,
to use no backup time keeper:

```C++
DS3231TimeKeeper dsTimeKeeper;
SystemTimeKeeper systemTimeKeeper(&dsTimeKeeper /*sync*/, nullptr /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  systemTimeKeeper.setup();
  ...
}
```

#### System Clock Heartbeat and Syncing

The `SystemTimeKeeper` requires 2 maintenance tasks to run periodically
to help it keep proper time.

First, the `SystemTimeKeeper::getNow()` method must be called peridically
before an internal integer overflow occurs, even if the `getNow()` is not
needed. The internal integer overflow happens every 65.536 seconds.
Even if your application is *guaranteed* to call `SystemTimeKeeper::getNow()`
faster than every 65 seconds, it is probably prudent to implement a "heartbeat"
mechanism which simply calls the `SystemTimeKeeper::getNow()` periodically
regardless of how often the application makes that call.

Secondly, since the internal `millis()` clock is not very accurate, we must
synchronize the `SystemTimeKeeper` periodically with a more accurate time
source. The frequency of this syncing depends on the accuracy of the `millis()`
(which depends on the hardware oscillator of the chip) and the cost of the call
to the `getNow()` method of the syncing time provider. If the syncing time
source is the DS3231 chip, syncing once every 1-10 minutes might be sufficient
since talking to the RTC chip is relatively cheap. If the syncing time source is
the `NtpTimeProvider`, the network connection is fairly expensive so maybe once
every 1-12 hours might be advisable.

The `SystemTimeKeeper` provides 2 ways to perform these periodic maintenance
actions. By default, the heartbeat happens every 5 seconds and the syncing
happens every 3600 seconds. Those parameters are configurable in the
constructors of the following classes.

**Method 1: Using the Global Loop() Function**

You can use the `SystemTimeSyncLoop` and `SystemTimeHeartbeatLoop` classes and
insert them somewhere into the global `loop()` method, like this:

```C++
SystemTimeKeeper systemTimeKeeper(...);
SystemTimeSyncLoop systemTimeSyncLoop(systemTimeKeeper);
SystemTimeHeartbeatLoop systemTimeHeartbeatLoop(systemTimeKeeper);

void loop() {
  ...
  systemTimeSyncLoop.loop();
  systemTimeHeartbeatLoop.loop();
  ...
}
```

We have assumed here that the global `loop()` function executes sufficiently
frequently, for example, faster than 10 or 100 times a second.

**Method 2: Using AceRoutine Coroutines**

You can use two [AceRoutine](https://github.com/bxparks/AceRoutine) coroutines
to perform the heartbeat and sync. First, `#include <AceRoutine.h>` *before* the
`#include <AceTime.h>` (which activates the `SystemTimeSyncCoroutine` and
`SystemTimeHeartbeatCoroutine` classes). Then create the 2 coroutines, and
configure it to run using the `CoroutineScheduler`:

```C++
#include <AceRoutine.h>
#include <AceTime.h>
...
SystemTimeKeeper systemTimeKeeper(...);
SystemTimeSyncCoroutine systemTimeSync(systemTimeKeeper);
SystemTimeHeartbeatCoroutine systemTimeHeartbeat(systemTimeKeeper);

void setup() {
  ...
  systemTimeSync.setupCoroutine(F("systemTimeSync"));
  systemTimeHeartbeat.setupCoroutine(F("systemTimeHeartbeat"));
  CoroutineScheduler::setup();
  ...
}

void loop() {
  CoroutineScheduler::loop();
  ...
}
```

The biggest advantage of using AceRoutine coroutines is that the syncing process
becomes non-blocking. In other words, if you are using the `NtpTimeProvider` to
provide syncing, the `SystemTimeSyncLoop` object calls its `getNow()` method,
which blocks the execution of the program until the NTP server returns a
response (or the request times out after 1000 milliseconds). If you use the
`SystemTimeSyncCoroutine`, the program continues to do other things (e.g. update
displays, scan for buttons) while the `NtpTimeProvider` is waiting for a
response from the NTP server.

## System Requirements

This library was developed and tested using:

* [Arduino IDE 1.8.9](https://www.arduino.cc/en/Main/Software)
* [ESP8266 Arduino Core 2.5.1](https://github.com/esp8266/Arduino)
* [ESP32 Arduino Core 1.0.2](https://github.com/espressif/arduino-esp32)

I used Ubuntu 18.04 for most of my development.

The library is tested on the following hardware before each release:

* Arduino Nano clone (16 MHz ATmega328P)
* Arduino Pro Micro clone (16 MHz ATmega32U4)
* WeMos D1 Mini clone (ESP-12E module, 80 MHz ESP8266)
* ESP32 dev board (ESP-WROOM-32 module, 240 MHz dual core Tensilica LX6)

I will occasionally test on the following hardware as a sanity check:

* Teensy 3.2 (72 MHz ARM Cortex-M4)

## Benchmarks

### CPU

The [AutoBenchmark.ino](examples/AutoBenchmark/) program measures the
amount of CPU cycles taken by some of the more expensive methods. Here is a
summary of the elapsed time for `OffsetDateTime::forEpochSeconds()` for some
Arduino boards that I have access to:
```
----------------------------+---------+
Board or CPU                |  micros |
----------------------------+---------+
ATmega328P 16MHz (Nano)     | 321.600 |
ESP8266 80MHz               |  13.400 |
ESP32 240MHz                |   1.470 |
Teensy 3.2 96MHz            |   2.130 |
----------------------------+---------+
```

### Memory

Here is a quick summary of the amount of static RAM consumed by various
classes:

**8-bit processors**

```
sizeof(LocalDate): 3
sizeof(LocalTime): 3
sizeof(LocalDateTime): 6
sizeof(TimeOffset): 1
sizeof(OffsetDateTime): 7
sizeof(ManualZoneSpecifier): 10
sizeof(BasicZoneSpecifier): 95
sizeof(ExtendedZoneSpecifier): 366
sizeof(TimeZone): 3
sizeof(ZonedDateTime): 10
sizeof(TimePeriod): 4
sizeof(SystemTimeKeeper): 17
sizeof(DS3231TimeKeeper): 3
sizeof(SystemTimeSyncLoop): 14
sizeof(SystemTimeHeartbeatLoop): 8
sizeof(SystemTimeSyncCoroutine): 31
sizeof(SystemTimeHeartbeatCoroutine): 18
```

**32-bit processors**
```
sizeof(LocalDate): 3
sizeof(LocalTime): 3
sizeof(LocalDateTime): 6
sizeof(TimeOffset): 1
sizeof(OffsetDateTime): 7
sizeof(ManualZoneSpecifier): 20
sizeof(BasicZoneSpecifier): 140
sizeof(ExtendedZoneSpecifier): 472
sizeof(TimeZone): 8
sizeof(ZonedDateTime): 16
sizeof(TimePeriod): 4
sizeof(SystemTimeKeeper): 24
sizeof(NtpTimeProvider): 88 (ESP8266), 116 (ESP32)
sizeof(SystemTimeSyncLoop): 20
sizeof(SystemTimeHeartbeatLoop): 12
sizeof(SystemTimeSyncCoroutine): 52
sizeof(SystemTimeHeartbeatCoroutine): 36
```

## Comparisons to Other Time Libraries

The [ComparisonBenchmark.ino](examples/ComparisonBenchmark/) program compares
the CPU time of AceTime methods with the equilvalent methods [Arduino Time
Library](https://github.com/PaulStoffregen/Time). The functionality tested was
the roundtrip conversion from `ZonedDateTime::forEpochSeconds()` to the date
time components, then back to `ZonedDateTime::toEpochSeconds()` again. Details
are given in the [README.md](examples/ComparisonBenchmark/README.md) file in
that folder, but here is a summary for various boards (all times in
microseconds):

```
----------------------------+---------+----------+
Board or CPU                | AceTime | Time Lib |
----------------------------+---------+----------+
ATmega328P 16MHz (Nano)     | 353.000 |  931.000 |
ESP8266 80MHz               |  21.600 |   68.100 |
ESP32 240MHz                |   2.145 |    9.355 |
Teensy 3.2 96MHz            |   2.330 |   22.390 |
----------------------------+---------+----------+
```

Compared to the
[AVR libc time library](https://www.nongnu.org/avr-libc/user-manual/group__avr__time.html),
which is based on the UNIX/POSIX time library, AceTime has the following
differences:
1. AceTime is written in C++ and provides more abstractions. For example, you
can create multiple system clocks if you need to.
1. AceTime is easier to understand and use (in my opinion of course).
1. All AceTime classes and methods are re-entrant (i.e. does not use static
buffers), except for `common::DateStrings` which is meant to be created
temporarily on the stack and discarded.
1. AceTime does not require an ISR (interrupt service routine) to be called at 1
second intervals to maintain the system clock. AceTime uses the `millis()`
method and synchronizes to it lazily when `SystemTimeKeeper::getNow()` is
called.
1. AceTime works across all platforms supported by the Arduino framework (e.g.
ESP8266 and ESP32), instead of just the AVR platform.
1. Both AceTime and AVR time libraries use an epoch of 2000-01-01T00:00:00Z.

## Bugs and Limitations

* `acetime_t`
    * AceTime uses an epoch of 2000-01-01T00:00:00Z.
      The `acetime_t` type is a 32-bit signed integer whose largest value is
      `INT32_MAX`, which corresponds to 2068-01-19T03:14:7Z.
    * The smallest date the `acetime_t` is `INT32_MIN` but that value is used to
      indicate an "invalid" value. Therefore, the smallest normal value is
      `INT32_MIN+1` which corresponds to 1931-12-13T20:45:53.
* `LocalDate`, `LocalDateTime`
    * These classes (and all other Date classes which are based on these) use
      a single 8-bit signed byte to represent the 'year' internally. This saves
      memory, at the cost of restricting the range.
    * The value of -128 (INT8_MIN) is used to indicate an "invalid" value, so
      the actual range is [-127, 127]. This restricts the year range to [1873,
      2127].
    * It is possible to construct a `LocalDate` or `LocalDateTime` object with a
      `year` component greater than 2127, but such an object may not be very
      useful because the `toSecondsSincEpoch()` method would exceed the range of
      `acetime_t, so would return an incorrect value.
* `toUnixSeconds()`
    * [Unix time](https://en.wikipedia.org/wiki/Unix_time) uses an epoch of
      1970-01-01T00:00:00Z. On 32-bit Unix systems that use a signed 32-bit
      integer to represent the seconds field, the unix time will rollover just
      after 2038-01-19T03:14:07Z.
* `BasicZoneSpecifier`, `ExtendedZoneSpecifier`
    * have been tested only between year 2000 and 2038 because the
      Python [pytz](https://pypi.org/project/pytz/) library supports dates only
      until Unix Epoch.
* `ExtendedZoneSpecifier`
    * There are 5 time zones (as of version 2019a of the TZ Database, see
      the bottom of `zonedbx/zone_infos.h`) which have DST transitions that occur at 00:01
      (one minute after midnight). This transition cannot be represented as a
      multiple of 15-minutes. The transition times of these zones have been
      shifted to the nearest 15-minute boundary, in other words, the transitions
      occur at 00:00 instead of 00:01. Clocks based on `ExtendedZoneSpecifier`
      will be off by one hour during the 1-minute interval from 00:00 and 00:01.
    * Fortunately all of these transitions happen before 2012. If you are
      interested in only dates after 2019, then this will not affect you.
* `NtpTimeProvider`
    * The `NtpTimeProvider` on an ESP8266 calls `WiFi.hostByName()` to resolve
      the IP address of the NTP server. Unfortunately, this seems to be blocking
      call. When the DNS resolver is working properly, this call returns in
      ~10ms or less. But sometimes, the DNS resolver seems to get into a state
      where it takes 4-5 **seconds** to time out. Even if you use coroutines,
      the entire program will block for those 4-5 seconds.
    * [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) uses an epoch
      of 1900-01-01T00:00:00Z, with 32-bit unsigned integer as the seconds
      counter. It will overflow just after 2036-02-07T06:28:15Z.
* `BasicValidationTest` and `ExtendedValidationTest`
    * These tests compare the transition times calculated by AceTime to Python's
      [pytz](https://pypi.org/project/pytz/) library. Unfortunately, pytz
      does not support dates after Unix epoch rollover (2038-01-19T03:14:07Z).
* `BasicValidationMoreTest` and `ExtendedValidationMoreTest`
    * These tests compare the transition times calculated by AceTime to Java's
      `java.time` package which should support the entire range of dates that
      AceTime can represent. We have artificially limited the range of testing
      from 2000 to 2050.

## Changelog

See [CHANGELOG.md](CHANGELOG.md).

## License

[MIT License](https://opensource.org/licenses/MIT)

## Feedback and Support

If you have any questions, comments, bug reports, or feature requests, please
file a GitHub ticket instead of emailing me unless the content is sensitive.
(The problem with email is that I cannot reference the email conversation when
other people ask similar questions later.) I'd love to hear about how this
software and its documentation can be improved. I can't promise that I will
incorporate everything, but I will give your ideas serious consideration.

## Authors

Created by Brian T. Park (brian@xparks.net).
