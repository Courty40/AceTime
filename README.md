# AceTime

This library provides date and time classes for the Arduino platform with
support for geographical time zones in the [IANA TZ
database](https://www.iana.org/time-zones). Date and time from one timezone can
be converted to another timezone. The library also provides a
SystemClock that can be synchronized from a more reliable external time
source, such as an [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol)
server or a [DS3231
RTC](https://www.maximintegrated.com/en/products/analog/real-time-clocks/DS3231.html)
chip. This library is meant to be an alternative to the [Arduino
Time](https://github.com/PaulStoffregen/Time) and [Arduino
Timezone](https://github.com/JChristensen/Timezone) libraries.

The AceTime classes are organized into roughly 4 bundles, placed in different
C++ namespaces:

* date and time classes
    * `ace_time::LocalTime`
    * `ace_time::LocalDate`
    * `ace_time::LocalDateTime`
    * `ace_time::TimeOffset`
    * `ace_time::OffsetDateTime`
    * `ace_time::ZoneSpecifier`
        * `ace_time::ManualZoneSpecifier`
        * `ace_time::BasicZoneSpecifier`
        * `ace_time::ExtendedZoneSpecifier`
    * `ace_time::TimeZone`
    * `ace_time::ZonedDateTime`
    * `ace_time::TimePeriod`
    * mutation helpers
        * `ace_time::date_time_mutation::*`
        * `ace_time::local_date_mutation::*`
        * `ace_time::time_offset_mutation::*`
        * `ace_time::time_period_mutation::*`
* system clock classes
    * `ace_time::provider::TimeProvider`
        * `ace_time::provider::TimeKeeper`
            * `ace_time::provider::SystemClock`
            * `ace_time::provider::DS3231TimeKeeper`
        * `ace_time::provider::NtpTimeProvider`
    * `ace_time::provider::SystemClockHeartbeatCoroutine`
    * `ace_time::provider::SystemClockHeartbeatLoop`
    * `ace_time::provider::SystemClockSyncCoroutine`
    * `ace_time::provider::SystemClockSyncLoop`
* TZ Database zone files
    * C++ files generated by a code-generator from the TZ Database zone files
    * `ace_time::zonedb` (231 timezones)
        * Used by `BasicZoneSpecifier`
        * `zonedb::kZoneAfrica_Abidjan`
        * `zonedb::kZoneAfrica_Accra`
        * ...227 other zones...
        * `zonedb::kZonePacific_Wake`
        * `zonedb::kZonePacific_Wallis`
    * `ace_time::zonedbx` (348 timezones)
        * Used by `ExtendedZoneSpecifier`
        * `zonedbx::kZoneAfrica_Abidjan`
        * `zonedbx::kZoneAfrica_Accra`
        * ...344 other zones...
        * `zonedbx::kZonePacific_Wake`
        * `zonedbx::kZonePacific_Wallis`
* Helper and common classes
    * `ace_time::acetime_t`
    * `ace_time::common::DateStrings`
    * `ace_time::common::ZoneContext`
    * `ace_time::basic::ZoneInfo`
    * `ace_time::basic::ZoneEra`
    * `ace_time::basic::ZonePolicy`
    * `ace_time::basic::ZoneRule`
    * `ace_time::extended::ZoneInfo`
    * `ace_time::extended::ZoneEra`
    * `ace_time::extended::ZonePolicy`
    * `ace_time::extended::ZoneRule`

The "date and time" classes provide a thin abstraction layer to make it easier
to use and manipulate date and time fields. For example, each of the
`LocalDateTime`, `OffsetDateTime` and `ZonedDateTime` classes provide the
`dayOfWeek()` method which returns the day of the week of the given date; the
`toEpochSeconds()` which returns the number of seconds from a epoch date; and
the `fromEpochSeconds()` which constructs the date and time fields from the
epoch seconds. The Epoch in AceTime is defined to be 2000-01-01T00:00:00Z,
in contrast to the Epoch in Unix which is 1970-01-01T00:00:00Z. Internally, the
current time is represented as "seconds from Epoch" which is a 32-bit signed
integer. The maximum date that AceTime can handle is 2068-01-19T03:14:07Z
(unlike 32-bit Unix whose maximum is 2038-01-19T03:14:07Z.) The `ZonedDateTime`
class works with the `TimeZone` class to provide access to the TZ Database and
allow conversions to other timezones using the
`ZonedDateTime::convertToTimeZone()` method.

The `ace_time::provider` classes collaborate together to implement the
SystemClock which can obtain its time from various sources, such as a DS3231 RTC
chip, or an Network Time Protocol (NTP) server. Retrieving the current time
from accurate clock sources can be expensive, so the `SystemClock` uses the
built-in `millis()` function to provide fast access to a reasonably accurate
clock, but synchronizes to more accurate clocks periodically.

The library provides 2 sets of "zone files" created from the IANA TZ Database:
* 231 zones generated in the `zonedb::` namespace which have (relatively) simple
  time zone transition rules, and intended to be used by `BasicZoneSpecifier`
  class, and
* 348 zones generated in the `zonedbx::` namespace which contain nearly all the
  zones in the TZ Database, intended to be used by the `ExtendedZoneSpecifier`
  class.

Both of these data sets have been unit tested from year 2000 to 2049
(inclusive). Custom datasets with smaller or larger range of years may be
generated by developers using scripts provided in this library. The target
application may be compiled against the custom dataset instead of using
`zonedb::` and `zonedbx::` zone files provided in this library.

Version: 0.1 (2019-06-15)

## HelloTime

Here is a simple program (see [examples/HelloTime](examples/HelloTime)) which
demonstrates how to create and manipulate date and times in different time
zones:

```C++
#include <AceTime.h>

using namespace ace_time;

// ZoneSpecifier instances should be created statically at initialization time.
static BasicZoneSpecifier pacificSpec(&zonedb::kZoneAmerica_Los_Angeles);
static BasicZoneSpecifier easternSpec(&zonedb::kZoneAmerica_New_York);
static ExtendedZoneSpecifier turkeySpec(&zonedbx::kZoneEurope_Istanbul);

void setup() {
  delay(1000);
  Serial.begin(115200); // ESP8266 default of 74880 not supported on Linux
  while (!Serial); // Wait until Serial is ready - Leonardo/Micro

  auto pacificTz = TimeZone::forZoneSpecifier(&pacificSpec);
  auto easternTz = TimeZone::forZoneSpecifier(&easternSpec);
  auto turkeyTz = TimeZone::forZoneSpecifier(&turkeySpec);

  // Create from components
  auto pacificTime = ZonedDateTime::forComponents(
      2019, 6, 1, 11, 38, 0, pacificTz);

  Serial.print(F("America/Los_Angeles: "));
  pacificTime.printTo(Serial);
  Serial.println();

  Serial.print(F("Epoch Seconds: "));
  acetime_t epochSeconds = pacificTime.toEpochSeconds();
  Serial.println(epochSeconds);

  Serial.print(F("Unix Seconds: "));
  acetime_t unixSeconds = pacificTime.toUnixSeconds();
  Serial.println(unixSeconds);

  // Create from epoch seconds
  auto easternTime = ZonedDateTime::forEpochSeconds(epochSeconds, easternTz);

  Serial.print(F("America/New_York: "));
  easternTime.printTo(Serial);
  Serial.println();

  // Create by conversion to time zone
  auto turkeyTime = easternTime.convertToTimeZone(turkeyTz);

  Serial.print(F("Europe/Istanbul: "));
  turkeyTime.printTo(Serial);
  Serial.println();

  Serial.print(F("pacificTime.compareTo(turkeyTime): "));
  Serial.println(pacificTime.compareTo(turkeyTime));

  Serial.print(F("pacificTime == turkeyTime: "));
  Serial.println((pacificTime == turkeyTime) ? "true" : "false");
}

void loop() {
}
```

Running this should produce the following on the Serial port:
```
 America/Los_Angeles: 2019-06-01T11:38:00-07:00 Saturday [America/Los_Angeles]
 Epoch Seconds: 612729480
 Unix Seconds: 1559414280
 America/New_York: 2019-06-01T14:38:00-04:00 Saturday [America/New_York]
 Europe/Istanbul: 2019-06-01T21:38:00+03:00 Saturday [Europe/Istanbul]
 pacific.compareTo(turkey): 0
 pacific == turkey: false
```

## Installation

The latest stable release will soon be available in the Arduino IDE Library
Manager. Search for "AceTime". Click Install.

The development version can be installed by cloning the
[GitHub repository](https://github.com/bxparks/AceTime), checking out the
`develop` branch, then manually copying over the contents to the `./libraries`
directory used by the Arduino IDE. (The result is a directory named
`./libraries/AceTime`.) The `master` branch contains the stable release.

### Source Code

The source files are organized as follows:
* `src/AceTime.h` - main header file
* `src/ace_time/` - date and time files
* `src/ace_time/common/` - internal shared files
* `src/ace_time/hw/` - thin hardware abstraction layer
* `src/ace_time/provider/` - providers from RTC or NTP sources
* `src/ace_time/testing/` - files used in unit tests
* `src/ace_time/zonedb/` - files generated from TZ Database for
  `BasicZoneSpecifier`
* `src/ace_time/zonedbx/` - files generated from TZ Database for
  `ExtendedZoneSpecifier`
* `tests/` - unit tests using [AUnit](https://github.com/bxparks/AUnit)
* `examples/` - example programs
* `tools/` - parser for the TZ Database files, code generators for `zonedb::`
  and `zonedbx::` zone files, and code generators for various unit tests

### Dependencies

The vast majority of the AceTime library has no dependency to any other external
libraries. There is an optional dependency to
[AceRoutine](https://github.com/bxparks/AceRoutine) if you want to use the
`SystemClockSyncCoroutine` and `SystemClockHeartbeatCoroutine` classes for
automatic syncing and freshening. (This is recommended but not strictly
necessary). The `ace_time/hw/CrcEeprom.h` class has a dependency to the FastCRC
library but the `CrcEeprom.h` file is not included in the `AceTime.h` main
header file, so you should not need FastCRC to compile AceTime. (The
`CrcEeprom.h` header file does not strictly belong in the AceTime library but
many of my "clock" projects that use the AceTime library also use the
`CrcEeprom` class, so this is a convenient place to keep it.)

Various programs in the `examples/` directory have one or more of the following
external dependencies. The comment section near the top of the `*.ino` file will
usually have more precise dependency information:

* [AceRoutine](https://github.com/bxparks/AceRoutine)
* [AceButton](https://github.com/bxparks/AceButton)
* [FastCRC](https://github.com/FrankBoesing/FastCRC)
* [SSD1306Ascii](https://github.com/greiman/SSD1306Ascii)
* [Arduino Time Lib](https://github.com/PaulStoffregen/Time)
* [Arduino Timezone](https://github.com/JChristensen/Timezone)

Various scripts in the `tools/` directory depend on:

* [TZ Database on GitHub](https://github.com/eggert/tz)
* [pytz library](https://pypi.org/project/pytz/)
* Python 3.5 or greater
* Java OpenJDK 11

### Docs

The [docs/](docs/) directory contains the
[Doxygen docs on GitHub Pages](https://bxparks.github.io/AceTime/html).

### Examples

The following example sketches are provided:

* [HelloTime](examples/HelloTime/)
    * demo program of various date and time classes
* [HelloSystemClock](examples/HelloSystemClock/)
    * demo program of `SystemClock`
* [HelloSystemClockCoroutine](examples/HelloSystemClockCoroutine/)
    * same as `SystemClock` but using AceRoutine coroutines
* [CommandLineClock](examples/CommandLineClock/)
    * a clock with a DS3231 RTC chip, an NTP client, and using the serial port
      for receiving commands and printing results, useful for debugging
* [OledClock](examples/OledClock/)
    * a digital clock using a DS3231 RTC chip, an NTP client, 2 buttons, and an
      SSD1306 OLED display
* [WorldClock](examples/WorldClock/)
    * a clock with 3 OLED screens showing the time at 3 different time zones
* [AutoBenchmark](examples/AutoBenchmark/)
    * perform CPU and memory benchmarking of various methods and print a report
* [ComparisonBenchmark](examples/ComparisonBenchmark/)
    * compare AceTime with
    [Arduino Time Lib](https://github.com/PaulStoffregen/Time)
* [CrcEepromDemo](examples/CrcEepromDemo/)
    * a program that verifies the `CrcEeprom` class

## Usage

The [AceTime User Guide](USER_GUIDE.md) is long enough to require a separate
document.

## System Requirements

This library was developed and tested using:

* [Arduino IDE 1.8.9](https://www.arduino.cc/en/Main/Software)
* [ESP8266 Arduino Core 2.5.1](https://github.com/esp8266/Arduino)
* [ESP32 Arduino Core 1.0.2](https://github.com/espressif/arduino-esp32)

I used Ubuntu 18.04 for most of my development.

The library is tested on the following hardware before each release:

* Arduino Nano clone (16 MHz ATmega328P)
* Arduino Pro Micro clone (16 MHz ATmega32U4)
* WeMos D1 Mini clone (ESP-12E module, 80 MHz ESP8266)
* ESP32 dev board (ESP-WROOM-32 module, 240 MHz dual core Tensilica LX6)

I will occasionally test on the following hardware as a sanity check:

* Teensy 3.2 (72 MHz ARM Cortex-M4)

## Changelog

See [CHANGELOG.md](CHANGELOG.md).

## License

[MIT License](https://opensource.org/licenses/MIT)

## Feedback and Support

If you have any questions, comments, bug reports, or feature requests, please
file a GitHub ticket instead of emailing me unless the content is sensitive.
(The problem with email is that I cannot reference the email conversation when
other people ask similar questions later.) I'd love to hear about how this
software and its documentation can be improved. I can't promise that I will
incorporate everything, but I will give your ideas serious consideration.

## Authors

Created by Brian T. Park (brian@xparks.net).
