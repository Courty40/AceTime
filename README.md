# AceTime

Date and time classes for Arduino with support for
[TZ database](https://en.wikipedia.org/wiki/Tz_database)
time zone support. It also supports an enhanced "system clock" that can be
synchronized from an external time source, such as an
[NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) server
or a DS3231 RTC chip. This library is meant to be an alternative to the
[Arduino Time](https://github.com/PaulStoffregen/Time) and
[Arduino Timezone](https://github.com/JChristensen/Timezone) libraries.

The date and time classes provide a thin abstraction for date and time fields,
mostly to allow conversion from Gregorian calendar components to epoch seconds.

Compared to the Arduino Time Library, here are the main differences:
1. AceTime provides more absstraction to make it easier to use. For example,
  you can create multiple instances of the system clock if you need to.
1. AceTime supports all zones defined by the TZ Database and corrects for
  DST (daylight saving time) transitions automatically.
1. AceTime uses an epoch that starts on 2000-01-01T00:00:00Z, where as
   Arduino Time Library uses the Unix epoch of 1970-01-01T00:00:00Z.
    * Using an `int32_t` (typedefed as `acetime_t`) to track the number of
      seconds since the Epoch, the AceTime library can handle all dates from
      approximately *1931* to the **2068**.
1. AceTime is **2-3X** faster on an ATmega328P, **4X** faster on the ESP8266,
   and **10-20X** faster on the ARM (Teensy) and ESP32 processors.
1. AceTime begins the week on a Monday, assigning 1=Monday and 7=Sunday, per ISO
   8601 standard, instead of beginning the week on a Sunday.

Compared to the
[AVR libc time library](https://www.nongnu.org/avr-libc/user-manual/group__avr__time.html),
which is based on the UNIX/POSIX time library, AceTime has the following
differences:
1. AceTime is written in C++ and is more object oriented. For example, you can
   create multiple system clocks if you need to.
1. AceTime is far easier to understand and use (in my opinion).
1. All AceTime classes and methods are re-entrant (i.e. does not use
  static buffers).
1. AceTime does not require an ISR to be called at 1 second intervals to
  maintain the system clock. AceTime uses the `millis()` method and
  synchronizes to it lazily when `SystemTimeKeeper::getNow()` is called.
1. AceTime works across all platforms supported by the Arduino framework
   (e.g. ESP8266 and ESP32), instead of just the AVR platform.
1. Both AceTime and AVR time library uses an epoch of 2000-01-01T00:00:00Z.

There are roughly 3 bundles of classes provided by the AceTime library:

* date and time primitives (`namespace ace_time`)
    * e.g `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`,
      `TimeZone`, `TimePeriod`
* system clock classes (`namespace ace_time::provider`)
    * e.g. `SystemTimeKeeper`, `NtpTimeProvider`, `DS3231TimeKeeper`
    * Implements the system clock syncing feature of the Arduino Time library.
* TZ Database zone files (`namespace ace_time::zonedb`)
    * C++ files generated by a code-generator from the TZ Database zone files

The AceTime library is inspired by and borrows from:
* [Java Time package](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/package-summary.html)
* [Micro Time Zone](https://github.com/evq/utz)
* [Arduino Timezone](https://github.com/JChristensen/Timezone)
* [Arduino Time](https://github.com/PaulStoffregen/Time)
* [Joda-Time](https://www.joda.org/joda-time/) Java library
* [Noda Time](https://nodatime.org/)
* [Python datetime](https://docs.python.org/3/library/datetime.html)

UTC offsets are internally represented as a single byte representing 15-minute
increments which supports every time zone offset currently used today.

Version: In-progress (2019-05-20)

## Installation

The latest stable release will soon be available in the Arduino IDE Library
Manager. Search for "AceTime". Click Install.

The development version can be installed by cloning the
[GitHub repository](https://github.com/bxparks/AceTime), checking out the
`develop` branch, then manually copying over the contents to the `./libraries`
directory used by the Arduino IDE. (The result is a directory named
`./libraries/AceTime`.) The `master` branch contains the stable release.

### Source Code

The source files are organized as follows:
* `src/AceTime.h` - main header file
* `src/ace_time/` - implementation files
* `src/ace_time/common/` - internal shared files
* `src/ace_time/hw/` - thin hardware abstraction layer
* `src/ace_time/provider/` - providers from RTC or NTP sources
* `src/ace_time/testing/` - files used in unit tests
* `src/ace_time/zonedb/` - TZ Database used by `BasicZoneSpecifier`
* `src/ace_time/zonedbx/` - TZ Database used by `ExtendedZoneSpecifier`
* `tests/` - unit tests using [AUnit](https://github.com/bxparks/AUnit)
* `examples/` - example programs
* `tools/` - scripts to parse the TZ Database files

### Dependencies

The main AceTime library itself has no external dependency. There is an
an optional dependency to
[AceRoutine](https://github.com/bxparks/AceRoutine)
if you want to use the `SystemTimeSyncCoroutine` and
`SystemTimeHeartbeatCoroutine` classes for automatic syncing and freshening.
(This is recommended but not strictly necessary).

Various sketches in the `examples/` directory have a number of external
dependencies (not all of the sketches require all of the following):

* [AceRoutine](https://github.com/bxparks/AceRoutine)
* [AceButton](https://github.com/bxparks/AceButton)
* [AceSegment](https://github.com/bxparks/AceSegment)
* [FastCRC](https://github.com/FrankBoesing/FastCRC)
* [SSD1306Ascii](https://github.com/greiman/SSD1306Ascii)

### Docs

The [docs/](docs/) directory contains the
[Doxygen docs on GitHub Pages](https://bxparks.github.io/AceTime/html).

### Examples

The following example sketches are provided:

* [AutoBenchmark.ino](examples/AutoBenchmark/)
    * a program that performs CPU and memory benchmarking and print a report
* [Clock.ino](examples/Clock/)
    * a digital clock using a DS3231 RTC chip, an NTP client, 2 buttons, and a
      SSD1306 OLED display
* [CommandLineClock.ino](examples/CommandLineClock/)
    * a clock using a DS3231 RTC chip, an NTP client, and serial port command
      line interface,
* [ComparisonBenchmark.ino](examples/ComparisonBenchmark/)
    * a program that compares the speed of AceTime with the
      [Arduino Time Library](https://github.com/PaulStoffregen/Time).
* [CrcEepromDemo.ino](examples/CrcEepromDemo/)
    * a program that verifies the `CrcEeprom` class

## Usage

### Include Header and Namespace

Only a single header file `AceTime.h` is required to use this library.
To prevent name clashes with other libraries that the calling code may use, all
classes are separated into a number of namespaces.

* Common utilities (`namespace ace_time::common`)
    * e.g. `DateStrings`
* Zone database files (`namespace ace_time::zonedb`, `ace_time::zonedbx`)
    * e.g. `zonedb::kZoneAmerica_Los_Angeles`
* Date Time primitives (`namespace ace_time`)
    * e.g. `ZonedDateTime`, `TimeZone`, `ZoneSpecifier`, `TimePeriod`
* Time providers (`namespace ace_time::provider`)
    * e.g. `SystemTimeKeeper`, `NtpTimeProvider`, `DS3231TimeKeeper`

Each namespace in the above depends on the classes of the previous namespace.
The `ace_time::provider` is mostly independent of `ace_time` except that
`DS3231TimeKeeper` uses `LocalDateTime` to convert between `epochSeconds`
and the `LocalDateTime`.

To use the classes without prepending the `ace_time::`, `ace_time::provider::`
or `ace_tme::common` prefixes, use one or more of the following `using`
directives:

```C++
#include <AceTime.h>
using namespace ace_time;
using namespace ace_time::provider;
using namespace ace_time::common;
```

### Epoch Typedef

One of the fundamental types in AceTime is the `acetime_t` defined as:
```C++
typedef int32_t acetime_t;
```
This represents the number of seconds since the Epoch. In AceTime, the Epoch is
defined to be 2000-01-01 00:00:00 UTC time. In contrast, Unix Epoch is defined
to be 1970-01-01 00:00:00 UTC.

### LocalDate and LocalTime

The `LocalDate` and `LocalTime` represent date and time components, without
reference to a particular time zone. They are not expected to be commonly used
by the end-users, but they are available if needed.

```C++
#include <AceTime.h>
using namespace ace_time;
[...]

// LocalDate that represents 2019-05-20
LocalDate localDate = LocalDate::forComponents(2019, 5, 20);

// LocalTime that represents 13:00:00
LocalTime localTime = LocalTime::forComponents(13, 0, 0);
```

You can ask the `LocalDate` to determine its day of the week, which returns
an integer where `1=Monday` and `7=Sunday` per 
[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601):
```C++
uint8_t dayOfWeek = localDate.dayOfWeek();
```
For convenience, the following constants are defined in `LocalDate`:
```C++
const uint8_t LocalDate::kMonday = 1;
const uint8_t LocalDate::kTuesday = 2;
const uint8_t LocalDate::kWednesday = 3;
const uint8_t LocalDate::kThursday = 4;
const uint8_t LocalDate::kFriday = 5;
const uint8_t LocalDate::kSaturday = 6;
const uint8_t LocalDate::kSunday = 7;
```

### Date Strings

To convert the `dayOfweek()` numerical code to a human-readable string for
debugging or display, we can use the `common::DateStrings` class:

```C++
#include <AceTime.h>
using namespace ace_time;
using common::DateStrings;
[...]

LocalDate localDate = LocalDate::forComponents(2019, 5, 20);
uint8_t dayOfWeek = localDate.dayOfWeek();
Serial.println(DateStrings().weekDayLongString(dayOfWeek));
Serial.println(DateStrings().weekDayShortString(dayOfWeek));
```
The `DateStrings` class is inside the `ace_time::common` namespace, so you need
to prefix it with `common::`. The `weekDayShortString()` method returns the
first 3 characters of the week day (i.e. "Mon", "Tue", "Wed", "Thu",
"Fri", "Sat", "Sun").

Similarly the `LocalDate::month()` method returns an integer code where
`1=January` and `12=December`. This integer code can be translated into English
strings using:

```C++
uint8_t month = localDate.month();
Serial.println(DateStrings().monthLongString(month));
Serial.println(DateStrings().monthShortString(month));
```
The `monthShortString()` method returns the first 3 characters of the month
(i.e. "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct",
"Nov", "Dec").

**Caution**: The `DateStrings` object uses a temporary internal buffer to hold
the generated human-readable strings. It is meant to be created temporarily on
the stack, used to extract the appropriate string, then reclaimed from the
stack. It is not meant to be created and persisted for a long period of time,
unless you are sure that nothing else will reuse the internal buffer between
calls.

**Caveat**: The `common::DateString` class supports only the English language.
If you need to convert to another language, you need to write the conversion
class yourself. See the implementation details of the `DateStrings` class to see
how that can be done.

### LocalDateTime

A `LocalDateTime` object holds both the date and time components
(year, month, day, hour, minute, second). Internally, it is implemented as a
combination of `LocalDate` and `LocalTime` and supports essentially all
operations on those classes. It does *not* support the notion of timezone.

```C++
LocalDateTime localDateTime;

// 2018-08-30T06:45:01-08:00
localDateTime = LocalDateTime::forComponents(2018, 8, 30, 6, 45, 1);
```

Once a `LocalDateTime` object is created you can access the individual date/time
components using the accessor methods:
```C++
int16_t year = localDateTime.year(); // 1872 - 2127
uint8_t month = localDateTime.month(); // 1 - 12
uint8_t day = localDateTime.day(); // 1 - 31
uint8_t hour = localDateTime.hour(); // 0 - 23
uint8_t minute = localDateTime.minute(); // 0 - 59
uint8_t second = localDateTime.second(); // 0 - 59
uint8_t dayOfWeek = localDateTime.dayOfWeek(); // 1=Monday, 7=Sunday
```

We can extract the number of seconds since AceTime Epoch
(2000-01-01T00:00:00Z) using the `toEpochSeconds()` method:
```C++
acetime_t epoch_seconds = localDateTime.toEpochSeconds();
```

We can go the other way and create a `LocalDateTime` from the Epoch Seconds:
```C++
LocalDateTime localDateTime = LocalDateTime::forEpochSeconds(1514764800L);
localDateTime.printTo(Serial); // prints "2018-01-01T00:00:00"
```

### OffsetDateTime

An `OffsetDateTime` is an object that can represent a date&time which is
offset from the UTC time zone by a fixed amount of time. Internally the
`OffsetDateTime` is a combination of `LocalDateTime` and `TimeOffset`. We can
create the object using the `forComponents()` method:
```C++
// 2018-01-01 00:00:00+00:15
OffsetDateTime offsetDateTime = OffsetDateTime::forComponents(
    2018, 1, 1, 0, 0, 0, TimeOffset::forHourMinute(1, 0, 15));
acetime_t epochDays = offsetDateTime.toEpochDays();
acetime_t epochSeconds = offsetDateTime.toEpochSeconds();

offsetDateTime.printTo(Serial); // prints "2018-01-01 00:00:00+00:15"
Serial.println(epochDays); // prints 6574
Serial.println(epochSeconds); // prints 568079100
```

You can go the other way and create a `DateTime` object from the seconds from
Epoch:
```C++
OffsetDateTime offsetDateTime = OffsetDateTime::forEpochSeconds(
    568079100, TimeOffset::forHourMinute(0, 0, 15));
```

### Invalid LocalDateTime or OffsetDateTime

A value of `LocalDate::kInvalidEpochSeconds` is used internally as an ERROR
marker so it is not possible to create a `LocalDateTime` or an `OffsetDateTime`
object with this value. In other words both of these:
```C++
LocalDateTime::forEpochSeconds(LocalDate::kInvalidEpochSeconds);
OffsetDateTime::forEpochSeconds(LocalDate::kInvalidEpochSeconds);
```
creates an object which returns `true` for the `isError()` method.

### TimeZone

A `ZonedDateTime` is an `OffsetDateTime` which also knows about its
`TimeZone`. The **AceTime** library supports 4 different types of `TimeZone`
roughly as follows:

    * `TimeZone::kTypeFixed` representing a fixed offset from UTC
    * `TimeZone::kTypeZoneSpecifier` (3 subtypes)
        * `ZoneSpecifier::kManual`: user-defined fixed offset
        * `ZoneSpecifier::kBasic`: a subset of the zones in the TZ database
        * `ZoneSpecifier::kExtended`:  all zones in the TZ database

To keep the tutorial simple, I will discuss only the `kTypeFixed` here. The
`kTypeZoneSpecifier` is described later.

The default constructor creates a fixed `TimeZone` in UTC time zone with no
offset:
```C++
TimeZone tz; // UTC+00:00
```

Here is a fixed `TimeZone` for UTC-08:00:
```C++
TimeZone tz(Utc::forHour(-8)); // UTC-08:00
```

### ZonedDateTime

A `ZonedDateTime` is a `LocalDateTime` associated with a given `TimeZone`. This
is similar to an `OffsetDateTime` being a `LocalDateTime` associated with a
given `TimeOffset`. (I will show later how a `ZonedDateTime` is more powerful
than an `OffsetDateTime`.)

```C++
// 2018-01-01 00:00:00+00:15
ZonedDateTime zonedDateTime = ZonedDateTime::forComponents(
    2018, 1, 1, 0, 0, 0,
    TimeZone::forTimeOffset(TimeOffset::forHourMinute(1, 0, 15)));
acetime_t epochDays = zonedDateTime.toEpochDays();
acetime_t epochSeconds = zonedDateTime.toEpochSeconds();

offsetDateTime.printTo(Serial); // prints "2018-01-01 00:00:00+00:15"
Serial.println(epochDays); // prints 6574
Serial.println(epochSeconds); // prints 568079100
```

#### Conversion to Other Time Zones

You can convert a given `DateTime` object into a representation in a different
time zone using the `DateTime::convertToTimeZone()` method:
```C++
// Central European Time
// 2018-01-01T09:20:00+01:00
DateTime cetTime = DateTime::forComponents(
    2018, 1, 1, 9, 20, 0, TimeZone::forHour(1));

// Convert to Pacific Daylight Time.
// 2018-01-01T01:20:00-07:00
DateTime pdtTime = dt.convertToTimeZone(TimeZone::forHour(-8).isDst(true));
```
The two `DateTime` objects return the same value for `epochSeconds()`
because that is not affected by the time zone. However, the various date time
components (year, month, day, hour, minute, seconds) will be different.

### TimePeriod

The `TimePeriod` class can be used to represents a difference between two
`DateTime` objects, if the difference is not too large. Internally, it is
implemented as 3 unsigned `uint8_t` integers representing the hour, minute and
seconds. There is a 4th signed `int8_t` integer that holds the sign (-1 or +1)
of the time period. The largest (or smallest) time period that can be
represented by this class is +/- 255h59m59s, corresponding to +/- 921599
seconds.

This class is intended to be used when the difference between 2 dates need
to be presented to the user broken down into hours, minutes and seconds. For
example, we can print out a count down to a target `DateTime` from the current
`DateTime` like this:
```C++
DateTime currentDate(...);
DateTime targetDate(...);
int32_t diffSeconds =
    targetDate.toEpochSeconds() - currentDate.toEpochSeconds();
TimePeriod diff(diffSeconds);
diff.printTo(Serial)
```

### TimeProviders and TimeKeepers

The `TimeProvider` class and its subclasses implement the `getNow()` method
which returns an `acetime_t` that represents the number of seconds since the
AceTime Epoch (2000-01-01T00:00:00Z). The relevant part of the `TimeProvider`
class is:

```C++
class TimeProvider {
  public:
    ...
    virtual acetime_t getNow() const = 0;
    ...
};
```

To obtain the human-readable version of the current time, create a
`DateTime` object from the seconds from Epoch returned by `getNow()`:
```C++
TimeProvider* timeProvider = ...;

acetime_t nowSeconds = timeProvider->getNow();
DateTime now(nowSeconds);
```

The `TimeKeeper` class and its subclasses are also subclasses of`TimeProvider`
but the time keepers implement the `setNow()` method which allows their time to
be set.
```C++
class TimeKeeper: public TimeProvider {
  public:
    virtual void setNow(acetime_t epochSeconds) = 0;
};
```

In other words, the `TimeKeeper` can be set to the current time. It is then
expected to have an internal clock that continues to update the current time.

The AceTime library comes with a number of time providers and keepers, as
described in the following subsections. All of these classes are in the
`ace_time::provider` namespace, and they do *not* depend on the
`DateTime` classes of the `ace_time` namespace.

```
#include <AceTime.h>
using namespace ace_time::provider;
```

#### DS3231 Time Keeper

The `DS3231TimeKeeper` is backed by a DS3231 RTC chip which is normally backed
by a battery or a supercapacitor to survive power failures. The DS3231 chip does
not contain the concept of a time zone. Therefore, I recommend that the
`DS3231TimeKeeper` class is used to store only the UTC date/time components,
instead of the local time. When the time is read back in using the
`DS3231TimeKeeper::getNow()`, you can convert that to the appropriate time zone
using the `DateTime::convertToTimeZone()` method.

```C++
DS3231TimeKeeper dsTimeKeeper;
...
void setup() {
  ...
  dsTimeKeeper.setup();
  ...

}
void loop() {
  ...
}
```

#### NTP Time Provider

The `NtpTimeProvider` is available on the ESP8266 and ESP32 have builtin WiFi
capability. This class uses an NTP client to fetch the current time from the
specified NTP server. The constructor takes 3 parameters which all of default
values so are optional.

You need to call the `setup()` with the `ssid` and `password` of the WiFi
connection. The method will time out after 5 seconds if the connection cannot
be established.

```C++
const char SSID[] = ...;
const char PASSWORD[] = ...;

NtpTimeProvider ntpTimeProvider;

void setup() {
  ...
  ntpTimeProvider.setup(SSID, PASSWORD);
  if (ntpTimeProvider.isSetup()) {
    Serial.println("WiFi connection failed... try again.");
  }
  ...
}

void loop() {
  ...
}
```
**Security Warning**: You should avoid committing your SSID and PASSWORD into a
public repository like GitHub because it will become public to anyone. Even if
you delete the commit, it will be accessible through the git history.

#### System Time Keeper

The `SystemTimeKeeper` is a special `TimeKeeper` that uses the Arduino built-in
`millis()` method as the source of its time. The biggest advantage of
`SystemTimeKeeper` is that its `getNow()` has very little overhead _(TBD: insert
benchmark)_ so it can be called as frequently as needed. The `getNow()` method
of other `TimeProviders` can consume a significant amount of time. For example,
the `DS3231TimeKeeper` must talk to the DS3231 RTC chip over an I2C bus. Even
worse, the `NtpTimeProvider` must the talk to the NTP server over the network
which can be unpredictably slow.

Unfortunately, the `millis()` internal clock of most (all?) Arduino boards is
not accurate. Therefore, the `SystemTimeKeeper` provides a mechanism to
synchronize its clock to an external (and presumably more accurate clock)
`TimeProvider`.

The `SystemTimeKeeper` also provides a way to save the current time to a
`backupTimeKeeper` (e.g. the `DS3231TimeKeeper` using an RTC chip with battery
backup). When the `SystemTimeKeeper` starts up, it will read the backup
`TimeKeeper` and set the current time. Then it can synchronize with an external
clock source (e.g. the `NtpTimeProvider`). The time is saved to the backup time
keeper whenever the `SystemTimeKeeper` is synced with the external time
provider.

Here is how to set up the `SystemTimeKeeper`:
```C++
DS3231TimeKeeper dsTimeKeeper;
NtpTimeProvider ntpTimeProvider(SSID, PASSWORD);
SystemTimeKeeper systemTimeKeeper(
  &ntpTimeProvider /*sync*/, &dsTimeKeeper /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  ntpTimeProvider.setup();
  systemTimeKeeper.setup();
  ...
}

void loop() {
}
```

If you wanted to use the `DS3231TimeKeeper` as *both* the backup and sync
time sources, then the setup would something like this:
```C++
DS3231TimeKeeper dsTimeKeeper;
SystemTimeKeeper systemTimeKeeper(
    &dsTimeKeeper /*sync*/, &dsTimeKeeper /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  systemTimeKeeper.setup();
  ...
}
```

You could also choose not to have either the backup or sync time sources, in
which case you can give `nullptr` as the correspond argument. For example,
to use no backup time keeper:
```C++
DS3231TimeKeeper dsTimeKeeper;
SystemTimeKeeper systemTimeKeeper(&dsTimeKeeper /*sync*/, nullptr /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  systemTimeKeeper.setup();
  ...
}
```

#### System Clock Syncing and Heartbeat

For technical reasons &mdash; see the implementation of
`SystemTimeKeeper::getNow()`) &mdash; the `getNow()` method must be called
periodically to avoid an integer overflow. The maximum period between 2
consecutive calls to `getNow()` is 65.535 seconds. We need to implement a
"heartbeat" mechanism which simply calls the `getNow()` of the system time
keeper.

Secondly, since the internal `millis()` clock is not very accurate, we must
synchronize the system time keeper periodically. The frequency depends on the
accurate of the `millis()` and the cost of the call to the `getNow()` method of
the syncing time provider. For a DS3231 time source, syncing once every 1-10
minutes might work since talking to the RTC chip is cheap. For syncing with the
`NtpTimeProvider` with an accurate `millis()` maybe once every 1-12 hours might
be advisable.

The `SystemTimeKeeper` provides 2 ways to perform these periodic maintenance
actions. By default, the syncing happens every 3600 seconds, and the heartbeat
happens every 5 seconds. Those parameters are configurable in the constructors
of the following classes.

**Method 1: Using the Global Loop()**

You can use the `SystemTimeSyncLoop` and `SystemTimeHeartbeatLoop` classes and
insert them into the global `loop()` method:

```C++
SystemTimeKeeper systemTimeKeeper(...);
SystemTimeSyncLoop systemTimeSyncLoop(systemTimeKeeper);
SystemTimeHeartbeatLoop systemTimeHeartbeatLoop(systemTimeKeeper);

void loop() {
  systemTimeSyncLoop.loop();
  systemTimeHeartbeatLoop.loop();
}
```

**Method 2: Using AceRoutine Coroutines**

You can use 2 AceRoutine coroutines to perform the sync and heartbeat. First,
`#include <AceRoutine.h>` before the `<AceTime.h>` (to activate the
`SystemTimeSyncCoroutine` and `SystemTimeHeartbeatCoroutine` classes). Then
create the 2 coroutines, and configure it to run using the `CoroutineScheduler`:

```C++
#include <AceRoutine.h>
#include <AceTime.h>
...
SystemTimeKeeper systemTimeKeeper(...);
SystemTimeSyncCoroutine systemTimeSync(systemTimeKeeper);
SystemTimeHeartbeatCoroutine systemTimeHeartbeat(systemTimeKeeper);

void setup() {
  ...
  systemTimeSync.setupCoroutine(F("systemTimeSync"));
  systemTimeHeartbeat.setupCoroutine(F("systemTimeHeartbeat"));
  CoroutineScheduler::setup();
  ...
}

void loop() {
  CoroutineScheduler::loop();
  ...
}
```

The biggest advantage of using AceRoutine coroutines is that the syncing process
becomes non-blocking. In other words, if you are using the `NtpTimeProvider` to
provide syncing, the `SystemTimeSyncLoop` object calls its `getNow()` method,
which blocks the execution of the program until the NTP server returns a
response (or the request times out after 1000 milliseconds). If you use the
coroutines, the program continues to do other things (e.g. update displays, scan
for buttons) during the time that the `NtpTimeProvider` has issued a request and
is waiting for a response from the NTP server.

## System Requirements

This library was developed and tested using:

* [Arduino IDE 1.8.5 - 1.8.7](https://www.arduino.cc/en/Main/Software)
* [ESP8266 Arduino Core 2.4.2](https://arduino-esp8266.readthedocs.io/en/2.4.2/)
* [arduino-esp32](https://github.com/espressif/arduino-esp32)

I used Ubuntu 17.10 for most of my development.

The library is tested on the following hardware before each release:

* Arduino Nano clone (16 MHz ATmega328P)
* Arduino Pro Micro clone (16 MHz ATmega32U4)
* WeMos D1 Mini clone (ESP-12E module, 80 MHz ESP8266)
* ESP32 dev board (ESP-WROOM-32 module, 240 MHz dual core Tensilica LX6)

I will occasionally test on the following hardware as a sanity check:

* Teensy 3.2 (72 MHz ARM Cortex-M4)

## Benchmarks

### CPU

The [AutoBenchmark.ino](examples/AutoBenchmark/) program measures the
amount of CPU cycles taken by some of the more expensive `DateTime`
methods. The most expensive method is the `DateTime::forEpochSeconds(seconds)`
factory method. Here is a summary of how long that constructor takes for some
Arduino boards that I have access to:
```
----------------------------+---------+
Board or CPU                |  micros |
----------------------------+---------+
ATmega328P 16MHz (Nano)     | 401.800 |
ESP8266 80MHz               |  12.080 |
ESP32 240MHz                |   0.705 |
Teensy 3.2 96MHz            |   2.750 |
----------------------------+---------+
```

### Memory

Here is a quick summary of the amount of static RAM consumed by various
classes:

**8-bit processors**

```
sizeof(DateTime): 8
sizeof(TimeZone): 1
sizeof(TimePeriod): 4
sizeof(SystemTimeKeeper): 17
sizeof(DS3231TimeKeeper): 4
sizeof(SystemTimeSyncLoop): 14
sizeof(SystemTimeHeartbeatLoop): 8
sizeof(SystemTimeSyncCoroutine): 29
sizeof(SystemTimeHeartbeatCoroutine): 18
```

**32-bit processors**
```
sizeof(DateTime): 8
sizeof(TimeZone): 1
sizeof(TimePeriod): 4
sizeof(SystemTimeKeeper): 24
sizeof(DS3231TimeKeeper): 8
sizeof(NtpTimeProvider): 96 (ESP8266), 120 (ESP32)
sizeof(SystemTimeSyncLoop): 20
sizeof(SystemTimeHeartbeatLoop): 12
sizeof(SystemTimeSyncCoroutine): 52
sizeof(SystemTimeHeartbeatCoroutine): 36
```

### Comparison to Arduino Time Library

The [ComparisonBenchmark.ino](examples/ComparisonBenchmark/) program compares
the CPU time of AceTime methods with the equilvalent methods
[Arduino Time Library](https://github.com/PaulStoffregen/Time).
The functionality tested was the roundtrip conversion from `secondsFromEpoch` to
the date time components, then back to `secondsFromEpoch` again. Details are
given in the README.md file in that folder, but here is a summary for various
boards (all times in microseconds):
```
----------------------------+---------+----------+
Board or CPU                | AceTime | Time Lib |
----------------------------+---------+----------+
ATmega328P 16MHz (Nano)     | 364.000 |  879.000 |
ESP8266 80MHz               |  20.900 |   68.500 |
ESP32 240MHz                |   0.570 |    9.330 |
Teensy 3.2 96MHz            |   1.980 |   22.570 |
----------------------------+---------+---------+
```

## Bugs and Limitations

* AceTime uses an epoch of 2000-01-01T00:00:00Z.
  `OffsetDateTime::toEpochSeconds()` returns the number of seconds since the
  epoch as a 32-bit unsigned integer. So it will rollover just after
  2136-02-07T06:28:15Z. However, the largest `int32_t` value of `INT32_MAX` is
  used by `OffsetDateTime::kInvalidEpochSeconds` to indicate an invalid value.
  Therefore, the actual largest possible dateTime is one second before that,
  i.e. 2136-02-07T06:28:14Z.
* It is possible to construct a `DateTime` object with a `year` component
  greater than 136, but such an object may not be very useful because the
  `toSecondsSincEpoch()` method would return an incorrect number.
* The `NtpTimeProvider` on an ESP8266 calls `WiFi.hostByName()` to resolve
  the IP address of the NTP server. Unfortunately, this seems to be blocking
  call. When the DNS resolver is working properly, this call returns in ~10ms or
  less. But sometimes, the DNS resolver seems to get into a state where it takes
  4-5 **seconds** to time out. Even if you use coroutines, the entire program
  will block for those 4-5 seconds.
* [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) uses an epoch
  of 1900-01-01T00:00:00Z, with 32-bit unsigned integer as the seconds counter.
  It will overflow just after 2036-02-07T06:28:15Z.
* [Unix time](https://en.wikipedia.org/wiki/Unix_time) uses an epoch of
  1970-01-01T00:00:00Z. On 32-bit Unix systems that use a signed 32-bit integer
  to represent the seconds field, the unix time will rollover just after
  2038-01-19T03:14:07Z.

## Changelog

See [CHANGELOG.md](CHANGELOG.md).

## License

[MIT License](https://opensource.org/licenses/MIT)

## Feedback and Support

If you have any questions, comments, bug reports, or feature requests, please
file a GitHub ticket or send me an email. I'd love to hear about how this
software and its documentation can be improved. Instead of forking the
repository to modify or add a feature for your own projects, let me have a
chance to incorporate the change into the main repository so that your external
dependencies are simpler and so that others can benefit. I can't promise that I
will incorporate everything, but I will give your ideas serious considerationk

## Authors

Created by Brian T. Park (brian@xparks.net).
