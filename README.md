# AceTime

Date and time classes for Arduino with support for
[TZ database](https://en.wikipedia.org/wiki/Tz_database)
time zone support. It also supports an enhanced "system clock" that can be
synchronized from an external time source, such as an
[NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) server
or a DS3231 RTC chip. This library is meant to be an alternative to the
[Arduino Time](https://github.com/PaulStoffregen/Time) and
[Arduino Timezone](https://github.com/JChristensen/Timezone) libraries.

The date and time classes provide a thin abstraction for date and time fields,
mostly to allow conversion from Gregorian calendar components to epoch seconds.

Compared to the Arduino Time Library, here are the main differences:
1. AceTime provides more abstraction to make it easier to use. For example,
  you can create multiple instances of the system clock if you need to.
1. AceTime supports all zones defined by the TZ Database and corrects for
  DST (daylight saving time) transitions automatically.
1. AceTime uses an epoch that starts on 2000-01-01T00:00:00Z, where as
   Arduino Time Library uses the Unix epoch of 1970-01-01T00:00:00Z.
    * Using an `int32_t` (typedefed as `acetime_t`) to track the number of
      seconds since the Epoch, the AceTime library can handle all dates from
      approximately *1931* to the **2068**.
1. AceTime is **2-3X** faster on an ATmega328P, **4X** faster on the ESP8266,
   and **10-20X** faster on the ARM (Teensy) and ESP32 processors.
1. AceTime begins the week on a Monday, assigning 1=Monday and 7=Sunday, per ISO
   8601 standard, instead of beginning the week on a Sunday.

Compared to the
[AVR libc time library](https://www.nongnu.org/avr-libc/user-manual/group__avr__time.html),
which is based on the UNIX/POSIX time library, AceTime has the following
differences:
1. AceTime is written in C++ and is more object oriented. For example, you can
   create multiple system clocks if you need to.
1. AceTime is far easier to understand and use (in my opinion).
1. All AceTime classes and methods are re-entrant (i.e. does not use
  static buffers).
1. AceTime does not require an ISR to be called at 1 second intervals to
  maintain the system clock. AceTime uses the `millis()` method and
  synchronizes to it lazily when `SystemTimeKeeper::getNow()` is called.
1. AceTime works across all platforms supported by the Arduino framework
   (e.g. ESP8266 and ESP32), instead of just the AVR platform.
1. Both AceTime and AVR time library uses an epoch of 2000-01-01T00:00:00Z.

There are roughly 3 bundles of classes provided by the AceTime library,
separated into namespaces:

* date and time classes
    * `ace_time::LocalDate`
    * `ace_time::LocalTime`
    * `ace_time::LocalDateTime`
    * `ace_time::TimeOffset`
    * `ace_time::OffsetDateTime`
    * `ace_time::ZoneSpecifier`
        * `ace_time::ManualZoneSpecifier`
        * `ace_time::BasicZoneSpecifier`
        * `ace_time::ExtendedZoneSpecifier`
    * `ace_time::ZonedDateTime`
    * `ace_time::TimeZone`
    * `ace_time::TimePeriod`
* system clock classes
    * `ace_time::provider::TimeProvider`
        * `ace_time::provider::TimeKeeper`
            * `ace_time::provider::SystemTimeKeeper`
            * `ace_time::provider::DS3231TimeKeeper`
        * `ace_time::provider::NtpTimeProvider`
    * `ace_time::provider::SystemTimeHeartbeatCoroutine`
    * `ace_time::provider::SystemTimeHeartbeatLoop`
    * `ace_time::provider::SystemTimeSyncCoroutine`
    * `ace_time::provider::SystemTimeSyncLoop`
* TZ Database zone files
    * C++ files generated by a code-generator from the TZ Database zone files
    * `ace_time::zonedb` (231 zones from TZ Database)
        * Used by `BasicZoneSpecifier`
        * `zonedb::kZoneAfrica_Johannesburg`
        * `zonedb::kZoneAmerica_Los_Angeles`
        * `zonedb::kZoneAmerica_Denver`
        * `zonedb::kZoneAmerica_Chicago`
        * `zonedb::kZoneAmerica_New_York`
        * `zonedb::kZoneAmerica_Moncton`
        * `zonedb::kZoneEurope_London`
        * `zonedb::kZoneEurope_Zurich`
        * ...
    * `ace_time::zonedbx` (all 348 zones from TZ Database)
        * Used by `ExtendedZoneSpecifier`
        * `zonedbx::kZoneAfrica_Cairo`
        * `zonedbx::kZoneAfrica_Casablanca`
        * `zonedbx::kZoneAmerica_Argentina_Buenos_Aires`
        * `zonedbx::kZoneAmerica_St_Johns`
        * `zonedbx::kZoneAmerica_Indiana_Indianapolis`
        * `zonedbx::kZoneAsia_Gaza`
        * ...

The AceTime library is inspired by and borrows from:
* [Java Time package](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/time/package-summary.html)
* [Micro Time Zone](https://github.com/evq/utz)
* [Arduino Timezone](https://github.com/JChristensen/Timezone)
* [Arduino Time](https://github.com/PaulStoffregen/Time)
* [Joda-Time](https://www.joda.org/joda-time/) Java library
* [Noda Time](https://nodatime.org/)
* [Python datetime](https://docs.python.org/3/library/datetime.html)

UTC offsets are internally represented as a single byte representing 15-minute
increments which supports every time zone offset currently used today.

Version: 0.1 (2019-05-31)

## Installation

The latest stable release will soon be available in the Arduino IDE Library
Manager. Search for "AceTime". Click Install.

The development version can be installed by cloning the
[GitHub repository](https://github.com/bxparks/AceTime), checking out the
`develop` branch, then manually copying over the contents to the `./libraries`
directory used by the Arduino IDE. (The result is a directory named
`./libraries/AceTime`.) The `master` branch contains the stable release.

### Source Code

The source files are organized as follows:
* `src/AceTime.h` - main header file
* `src/ace_time/` - implementation files
* `src/ace_time/common/` - internal shared files
* `src/ace_time/hw/` - thin hardware abstraction layer
* `src/ace_time/provider/` - providers from RTC or NTP sources
* `src/ace_time/testing/` - files used in unit tests
* `src/ace_time/zonedb/` - TZ Database used by `BasicZoneSpecifier`
* `src/ace_time/zonedbx/` - TZ Database used by `ExtendedZoneSpecifier`
* `tests/` - unit tests using [AUnit](https://github.com/bxparks/AUnit)
* `examples/` - example programs
* `tools/` - scripts to parse the TZ Database files

### Dependencies

The main AceTime library itself has no external dependency. There is an
an optional dependency to
[AceRoutine](https://github.com/bxparks/AceRoutine)
if you want to use the `SystemTimeSyncCoroutine` and
`SystemTimeHeartbeatCoroutine` classes for automatic syncing and freshening.
(This is recommended but not strictly necessary).

Various sketches in the `examples/` directory have a number of external
dependencies (not all of the sketches require all of the following):

* [AceRoutine](https://github.com/bxparks/AceRoutine)
* [AceButton](https://github.com/bxparks/AceButton)
* [AceSegment](https://github.com/bxparks/AceSegment)
* [FastCRC](https://github.com/FrankBoesing/FastCRC)
* [SSD1306Ascii](https://github.com/greiman/SSD1306Ascii)

### Docs

The [docs/](docs/) directory contains the
[Doxygen docs on GitHub Pages](https://bxparks.github.io/AceTime/html).

### Examples

The following example sketches are provided:

* [AutoBenchmark.ino](examples/AutoBenchmark/)
    * a program that performs CPU and memory benchmarking and print a report
* [Clock.ino](examples/Clock/)
    * a digital clock using a DS3231 RTC chip, an NTP client, 2 buttons, and a
      SSD1306 OLED display
* [CommandLineClock.ino](examples/CommandLineClock/)
    * a clock using a DS3231 RTC chip, an NTP client, and serial port command
      line interface,
* [ComparisonBenchmark.ino](examples/ComparisonBenchmark/)
    * a program that compares the speed of AceTime with the
      [Arduino Time Library](https://github.com/PaulStoffregen/Time).
* [CrcEepromDemo.ino](examples/CrcEepromDemo/)
    * a program that verifies the `CrcEeprom` class

## Usage

### Include Header and Namespace

Only a single header file `AceTime.h` is required to use this library.
To prevent name clashes with other libraries that the calling code may use, all
classes are separated into a number of namespaces. They are related in the
following way, where the arrow means "depends on":

```
ace_time::provider
        |        \
        |         \
        |          v
        |          ace_time
        |           |     \
        |           |\     \
        |           | \     v
        |           |  \    ace_time::zonedb
        |           |   \   ace_time::zonedbx
        |           |    \     |
        v           |     v    v
ace_time::hw        |     ace_time::basic
                    |     ace_time::extended
                    |       /
                    |      /
                    v     v
              ace_time::common
```

To use the classes without prepending the namespace prefixes, use one or more of
the following `using` one or more of the following directives:

```C++
#include <AceTime.h>
using namespace ace_time;
using namespace ace_time::provider;
using namespace ace_time::common;
using namespace ace_time::zonedb;
using namespace ace_time::zonedbx;
...
```

### Epoch Seconds Typedef

One of the fundamental types in AceTime is the `acetime_t` defined as:
```C++
typedef int32_t acetime_t;
```
This represents the number of seconds since the Epoch. In AceTime, the Epoch is
defined to be 2000-01-01 00:00:00 UTC time. In contrast, Unix Epoch is defined
to be 1970-01-01 00:00:00 UTC.

### LocalDate and LocalTime

The `LocalDate` and `LocalTime` represent date and time components, without
reference to a particular time zone. They are not expected to be commonly used
by the end-users, but they are available if needed.

```C++
#include <AceTime.h>
using namespace ace_time;
...

// LocalDate that represents 2019-05-20
LocalDate localDate = LocalDate::forComponents(2019, 5, 20);

// LocalTime that represents 13:00:00
LocalTime localTime = LocalTime::forComponents(13, 0, 0);
```

You can ask the `LocalDate` to determine its day of the week, which returns
an integer where `1=Monday` and `7=Sunday` per
[ISO 8601](https://en.wikipedia.org/wiki/ISO_8601):
```C++
uint8_t dayOfWeek = localDate.dayOfWeek();
```
For convenience, the following constants are defined in `LocalDate`:
```C++
const uint8_t LocalDate::kMonday = 1;
const uint8_t LocalDate::kTuesday = 2;
const uint8_t LocalDate::kWednesday = 3;
const uint8_t LocalDate::kThursday = 4;
const uint8_t LocalDate::kFriday = 5;
const uint8_t LocalDate::kSaturday = 6;
const uint8_t LocalDate::kSunday = 7;
```

### Date Strings

To convert the `dayOfweek()` numerical code to a human-readable string for
debugging or display, we can use the `common::DateStrings` class:

```C++
#include <AceTime.h>
using namespace ace_time;
using common::DateStrings;
...

LocalDate localDate = LocalDate::forComponents(2019, 5, 20);
uint8_t dayOfWeek = localDate.dayOfWeek();
Serial.println(DateStrings().weekDayLongString(dayOfWeek));
Serial.println(DateStrings().weekDayShortString(dayOfWeek));
```
The `DateStrings` class is inside the `ace_time::common` namespace, so you need
to prefix it with `common::`. The `weekDayShortString()` method returns the
first 3 characters of the week day (i.e. "Mon", "Tue", "Wed", "Thu",
"Fri", "Sat", "Sun").

Similarly the `LocalDate::month()` method returns an integer code where
`1=January` and `12=December`. This integer code can be translated into English
strings using:

```C++
uint8_t month = localDate.month();
Serial.println(DateStrings().monthLongString(month));
Serial.println(DateStrings().monthShortString(month));
```
The `monthShortString()` method returns the first 3 characters of the month
(i.e. "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct",
"Nov", "Dec").

**Caution**: The `DateStrings` object uses a temporary internal buffer to hold
the generated human-readable strings. It is meant to be created temporarily on
the stack, used to extract the appropriate string, then reclaimed from the
stack. It is not meant to be created and persisted for a long period of time,
unless you are sure that nothing else will reuse the internal buffer between
calls.

**Caveat**: The `common::DateString` class supports only the English language.
If you need to convert to another language, you need to write the conversion
class yourself. See the implementation details of the `DateStrings` class to see
how that can be done.

### LocalDateTime

A `LocalDateTime` object holds both the date and time components
(year, month, day, hour, minute, second). Internally, it is implemented as a
combination of `LocalDate` and `LocalTime` and supports essentially all
operations on those classes. It does *not* support the notion of timezone.

```C++
LocalDateTime localDateTime;

// 2018-08-30T06:45:01-08:00
localDateTime = LocalDateTime::forComponents(2018, 8, 30, 6, 45, 1);
```

Once a `LocalDateTime` object is created you can access the individual date/time
components using the accessor methods:
```C++
int16_t year = localDateTime.year(); // 1872 - 2127
uint8_t month = localDateTime.month(); // 1 - 12
uint8_t day = localDateTime.day(); // 1 - 31
uint8_t hour = localDateTime.hour(); // 0 - 23
uint8_t minute = localDateTime.minute(); // 0 - 59
uint8_t second = localDateTime.second(); // 0 - 59
uint8_t dayOfWeek = localDateTime.dayOfWeek(); // 1=Monday, 7=Sunday
```

We can extract the number of seconds since AceTime Epoch
(2000-01-01T00:00:00Z) using the `toEpochSeconds()` method:
```C++
acetime_t epoch_seconds = localDateTime.toEpochSeconds();
```

We can go the other way and create a `LocalDateTime` from the Epoch Seconds:
```C++
LocalDateTime localDateTime = LocalDateTime::forEpochSeconds(1514764800L);
localDateTime.printTo(Serial); // prints "2018-01-01T00:00:00"
```
### TimeOffset

A `TimeOffset` class represents an amount of time shift from a reference point.
Often the reference is the UTC time and this class represents the amount of time
shift from UTC. Currently (year 2019) every time zone in the world is shifted
from UTC by a multiple of 15 minutes (e.g. -03:30 or +01:00). `TimeOffset` is a
thin wrapper around a single 8-bit signed integer which can encode integers from
[-128, 127]. Internally -128 is used to indicate an error condition, so we can
represent a UTC shift of from -31:45 to +31:45 hours, which is more than enough
to encode all UTC offsets currently in use.

A `TimeOffset` can be created using a number of factory methods:
```C++
TimeOffset offset = TimeOffset::forHour(-8); // -08:00
TimeOffset offset = TimeOffset::forHourMinute(-2, 30); // -02:30
TimeOffset offset = TimeOffset::forMinutes(135); // +02:15
```

A `TimeOffset` instance can be converted into different formats:
```C++
int32_t seconds = offset.toSeconds();
int16_t minutes = offset.toMinutes();

int8_t hour;
uint8_t minute;
offset.toHourMinute(&hour, &minute);
```

When a method returns a `TimeOffset`, it is useful to return an error indicator
which can be created by the special factory method `TimeOffset::forError()`. It
returns an instance whose `TimeOffset::isError()` returns `true`. Internally,
this is an instance whose internal integer code is -128.

The convenience method `TimeOffset::isZero()` returns `true` if the offset has a
zero offset. This is often used to determine if a timezone is currently
observing Daylight Saving Time (DST).

### OffsetDateTime

An `OffsetDateTime` is an object that can represent a date&time which is
offset from the UTC time zone by a fixed amount of time. Internally the
`OffsetDateTime` is a aggregation of `LocalDateTime` and `TimeOffset`. We can
create the object using the `forComponents()` method:
```C++
// 2018-01-01 00:00:00+00:15
OffsetDateTime offsetDateTime = OffsetDateTime::forComponents(
    2018, 1, 1, 0, 0, 0, TimeOffset::forHourMinute(0, 15));
acetime_t epochDays = offsetDateTime.toEpochDays();
acetime_t epochSeconds = offsetDateTime.toEpochSeconds();

offsetDateTime.printTo(Serial); // prints "2018-01-01 00:00:00+00:15"
Serial.println(epochDays); // prints 6574
Serial.println(epochSeconds); // prints 568079100
```

You can create a `DateTime` object from the seconds from Epoch using
the `forEpochSeconds()` method:
```C++
OffsetDateTime offsetDateTime = OffsetDateTime::forEpochSeconds(
    568079100, TimeOffset::forHourMinute(0, 15));
```

### Invalid LocalDateTime or OffsetDateTime

A value of `LocalDate::kInvalidEpochSeconds` is used internally as an ERROR
marker so it is not possible to create a `LocalDateTime` or an `OffsetDateTime`
object with this value. In other words both of these:
```C++
LocalDateTime::forEpochSeconds(LocalDate::kInvalidEpochSeconds);
OffsetDateTime::forEpochSeconds(LocalDate::kInvalidEpochSeconds);
```
creates an object which returns `true` for the `isError()` method.

### TimeZone

A `TimeZone` class represents a physical (or conceptual) region whose local time
is offset by a certain amount from the UTC time. The UTC offset could be a fixed
amount. Or the offset could be fixed with a user-selectable DST flag that
increases the offset by one hour. Or the offset could be algorithmically
determined using rules which are encoded by the TZ Database. The `TimeZone`
class supports all these modes.

The 4 different types of `TimeZone` are as follows:

* `TimeZone::kTypeFixed`: a fixed offset from UTC
* `TimeZone::kTypeZoneSpecifier` with `ManualZoneSpecifier`: user-defined fixed offset
* `TimeZone::kTypeZoneSpecifier` with `BasicZoneSpecifier`: zones with
   simple rules in the TZ Database
* `TimeZone::kTypeZoneSpecifier` with `ExtendedZoneSpecifier`:  all zones in the TZ Database

The `TimeZone` class exposes the following methods:
```C++
class TimeZone {
  public:
    TimeOffset getUtcOffset(acetime_t epochSeconds) const;
    TimeOffset getDeltaOffset(acetime_t epochSeconds) const;
    TimeOffset getUtcOffsetForDateTime(const LocalDateTime& ldt) const;
    void printAbbrevTo(Print& printer, acetime_t epochSeconds) const;
    ...
};
```

The `getUtcOffset(epochSeconds)` returns the total `TimeOffset` including any
DST offset at the given `epochSeconds`. The `getDeltaOffset()` returns only the
additional DST offset; if DST is not in effect at the given `epochSeconds`, this
returns 0.

The `getUtcOffsetForDateTime()` method returns the best guess of the total UTC
offset at the given local date time. The local date time is sometime ambiguious
during a DST transition. For example, if the local clock shifts from 01:00 to
02:00 at the start of summer, then the time of 01:30 does not exist. If the
`getUtcOffsetForDateTime()` method is given a non-existing time, it must make an
educated guess at what the user meant. Additionally, when the local time
transitions from 02:00 to 01:00 in the autumn, a given local time such as 01:30
occurs twice. If the `getUtcOffsetForDateTime()` method is given a time of
01:30, it will arbitrarily decide the offset to return.

The `printAbbrevTo(epochSeconds)` method prints the human-readable timezone
abbreviation used at the given `epochSeconds`.

The 4 different `TimeZone` types are described further below.

#### Fixed TimeZone

The default constructor creates a fixed `TimeZone` in UTC time zone with no
offset:
```C++
TimeZone tz; // UTC+00:00
```

To create `TimeZone` instances with other offsets, use one of the factory
methods:
```C++
TimeZone tz = TimeZone::forTimeOffset(TimeOffset::forHour(-8)); // UTC-08:00
TimeZone tz = TimeZone::forTimeOffset(TimeOffset::forHourMinute(-4, 30)); // UTC-04:30
```

#### ManualZoneSpecifier

A `ManualZoneSpecifier` describes a time zone which allows the user to set
the UTC offset, and to select whether or not the DST offset is being observed.
The constructor looks like this:
```C++
ManualZoneSpecifier(
    TimeOffset stdOffset = TimeOffset(),
    bool isDst = false,
    const char* stdAbbrev = "",
    const char* dstAbbrev = "",
    TimeOffset deltaOffset = TimeOffset::forHour(1));
```
All the parameters are theoretically optional, but most applications will
set the `stdOffset` at least:

* `stdOffset`: the standard time UTC offset (default: 00:00)
* `isDst`: whether the DST is being observed (default: false)
* `stdAbbrev`: the abbreviation during standard time (default: "")
* `dstAbbrev`: the abbreviation during DST (default: "")
* `deltaOffset`: the time shift during DST (default: +01:00)

When `ManualZoneSpecifier::getUtcOffset()` is called, it will normally return
the value of `stdOffset`. However, if the user sets the `isDst` flag to `true`
using `ManualZoneSpecifier::isDst(true)`, then `getUtcOffset()` will return
`stdOffset + deltaOffset`.

The `ManualZoneSpecifier` is expected to be created once at the beginning of
the application. The `TimeZone` object can be created on demand by pointing it
to the `ManualZoneSpecifier` instance. For example, the following creates a
`TimeZone` set to be UTC-08:00 normally, but can change to UTC-07:00 when the
`ManualZoneSpecifier::isDst(true)` is called:

```C++
ManualZoneSpecifier zoneSpecifier(TimeOffset::forHour(-8), false, "PST", "PDT");

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);
  TimeOffset offset = tz.getUtcOffset(0); // returns -08:00
  tz.isDst(true);
  offset = tz.getUtcOffset(0); // returns -07:00
  ...
}
```

The `TimeZone::isDst()` and `TimeZone::isDst(bool)` methods are convenience
methods that work only if the `TimeZone` instance refers to a
`ManualZoneSpecifier`. They simply call the underying `ManualZoneSpecifier`. If
the underlying `ZoneSpecifier` is a different type, the `TimeZone::isDst()` does
nothing.

#### BasicZoneSpecifier

The `BasicZoneSpecifier` represents a time zone defined by the TZ Database. The
constructor accepts a pointer to a `basic::ZoneInfo`:
```C++
BasicZoneSpecifier(const basic::ZoneInfo* zoneInfo);
```

The supported `basic::ZoneInfo` data objects are contained in
[zonedb/zone_info.h](src/ace_time/zonedb/zone_infos.h) which was generated by
a script using the TZ Database. This header file is already included in
`<AceTime.h>`. As of version 2019a of the database, it contains 231 zones whose
time change rules are simple enough to be supported by `BasicZoneSpecifier`. The
bottom of the `zone_infos.h` header file lists 128 zones whose zone rules are
too complicated for `BasicZoneSpecifier`. Some examples of `ZoneInfo` entries
supported by `zonedb` are:

* `zonedb::kZoneAmerica_Los_Angeles`
* `zonedb::kZoneAmerica_New_York`
* `zonedb::kZoneEurope_London`
* ...


The following example creates a `TimeZone` using a `BasicZoneSpecifier` which
describes `America/Los_Angeles`:

```C++
#include <AceTime.h>
using namespace ace_time;
...

BasicZoneSpecifier zoneSpecifier(&zonedb::kZoneAmerica_Los_Angeles);

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);

  // 2018-03-11T01:59:59-08:00 was still in STD time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 1, 59, 59,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -08:00
  }

  // 2018-03-11T02:00:00-08:00 was in DST time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 2, 0, 0,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -07:00
  }
  ...
}
```

#### ExtendedZoneSpecifier

The `ExtendedZoneSpecifier` is very similar to `BasicZoneSpecifier` except that
it supports (almost) all zones in the TZ Database instead of a subset. The
supported zones are given in
[zonedbx/zone_infos.h](src/ace_time/zonedbx/zone_infos.h).
As of version 2019a of TZ Database, there are 348 supported time zones. We`
ignore the 11 zones are those whose zone names do **not** contain a `/`
character (CET, CST6CDT, EET, EST, EST5EDT, HST, MET, MST, MST7MDT, PST8PDT,
WET) because they don't correspond to an actual geographical zone.

The zone infos which can be used by `ExtendedZoneSpecifier` are in the
`zonedbx::` namespace instead of the `zonedb::` namespace. Some examples of the
zone infos are:
* `zonedbx::kZoneAmerica_Los_Angeles`
* `zonedbx::kZoneAmerica_Indiana_Indianapolis`
* `zonedbx::kZoneAmerica_New_York`
* `zonedbx::kZoneEurope_London`
* `zonedbx::kZoneAfrica_Casablanca`
* ...

The usage is the same as `BasicZoneSpecifier`:
```C++
ExtendedZoneSpecifier zoneSpecifier(&zonedbx::kZoneAmerica_Los_Angeles);

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);

  // 2018-03-11T01:59:59-08:00 was still in STD time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 1, 59, 59,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -08:00
  }

  // 2018-03-11T02:00:00-08:00 was in DST time
  {
    OffsetDateTime dt = OffsetDateTime::forComponents(2018, 3, 11, 2, 0, 0,
      TimeOffset::forHour(-8));
    acetime_t epochSeconds = dt.toEpochSeconds();
    TimeOffset offset = tz.getUtcOffset(epochSeconds); // returns -07:00
  }
  ...
}
```

The advantage of `ExtendedZoneSpecifier` over `BasicZoneSpecifier` is that
`ExtendedZoneSpecifier` supports all time zones in the TZ Database. The cost is
that it consumes 5 times more memory and is slower. If `BasicZoneSpecifier`
supports the zone that you are interested in using the zone files in the
`zonedb::` namespace, you should normally use that instead of
`ExtendedZoneSpecifier`.

### ZonedDateTime

A `ZonedDateTime` is a `LocalDateTime` associated with a given `TimeZone`. This
is analogous to an`OffsetDateTime` being a `LocalDateTime` associated with a
`TimeOffset`.

```C++
BasicZoneSpecifier zoneSpecifier(&zonedb::kZoneAmerica_Los_Angeles);

void someFunction() {
  ...
  TimeZone tz = TimeZone::forZoneSpecifier(&zoneSpecifier);

  // 2018-01-01 00:00:00+00:15
  ZonedDateTime zonedDateTime = ZonedDateTime::forComponents(
      2018, 1, 1, 0, 0, 0, tz);
  acetime_t epochDays = zonedDateTime.toEpochDays();
  acetime_t epochSeconds = zonedDateTime.toEpochSeconds();

  zonedDateTime.printTo(Serial); // prints "2018-01-01 00:00:00-08:00"
  Serial.println(epochDays); // prints 6574 [TODO: Check]
  Serial.println(epochSeconds); // prints 568079100 [TODO: Check]
  ...
}
```

#### Conversion to Other Time Zones

You can convert a given `DateTime` object into a representation in a different
time zone using the `DateTime::convertToTimeZone()` method:
```C++
BasicZoneSpecifier zspecLosAngeles(&zonedb::kZoneAmerica_Los_Angeles);
BasicZoneSpecifier zspecZurich(&zonedb::kZoneEurope_Zurich);

void someFunction() {
  ...
  TimeZone tzLosAngeles = TimeZone::forZoneSpecifier(&zspecLosAngeles);
  TimeZone tzZurich = TimeZone::forZoneSpecifier(&zspecZurich);

  // Europe/Zurich, 2018-01-01T09:20:00+01:00
  ZonedDateTime zurichTime = ZonedDateTime::forComponents(
      2018, 1, 1, 9, 20, 0, tzZurich);

  // Convert to America/Los_Angeles, 2018-01-01T01:20:00-08:00
  ZonedDateTime losAngelesTime = zurichTime.convertToTimeZone(tzLosAngeles);
  ...
}
```

The two `ZonedDateTime` objects will return the same value for `epochSeconds()`
because that is not affected by the time zone. However, the various date time
components (year, month, day, hour, minute, seconds) will be different.

### TimePeriod

The `TimePeriod` class can be used to represents a difference between two
`DateTime` objects, if the difference is not too large. Internally, it is
implemented as 3 unsigned `uint8_t` integers representing the hour, minute and
seconds. There is a 4th signed `int8_t` integer that holds the sign (-1 or +1)
of the time period. The largest (or smallest) time period that can be
represented by this class is +/- 255h59m59s, corresponding to +/- 921599
seconds.

This class is intended to be used when the difference between 2 dates need
to be presented to the user broken down into hours, minutes and seconds. For
example, we can print out a count down to a target `DateTime` from the current
`DateTime` like this:
```C++
DateTime currentDate(...);
DateTime targetDate(...);
int32_t diffSeconds =
    targetDate.toEpochSeconds() - currentDate.toEpochSeconds();
TimePeriod diff(diffSeconds);
diff.printTo(Serial)
```

### TimeProviders and TimeKeepers

The `TimeProvider` class and its subclasses implement the `getNow()` method
which returns an `acetime_t` that represents the number of seconds since the
AceTime Epoch (2000-01-01T00:00:00Z). The relevant part of the `TimeProvider`
class is:

```C++
class TimeProvider {
  public:
    ...
    virtual acetime_t getNow() const = 0;
    ...
};
```

To obtain the human-readable version of the current time, create a
`DateTime` object from the seconds from Epoch returned by `getNow()`:
```C++
TimeProvider* timeProvider = ...;

acetime_t nowSeconds = timeProvider->getNow();
DateTime now(nowSeconds);
```

The `TimeKeeper` class and its subclasses are also subclasses of`TimeProvider`
but the time keepers implement the `setNow()` method which allows their time to
be set.
```C++
class TimeKeeper: public TimeProvider {
  public:
    virtual void setNow(acetime_t epochSeconds) = 0;
};
```

In other words, the `TimeKeeper` can be set to the current time. It is then
expected to have an internal clock that continues to update the current time.

The AceTime library comes with a number of time providers and keepers, as
described in the following subsections. All of these classes are in the
`ace_time::provider` namespace, and they do *not* depend on the
`DateTime` classes of the `ace_time` namespace.

```
#include <AceTime.h>
using namespace ace_time::provider;
```

#### DS3231 Time Keeper

The `DS3231TimeKeeper` is backed by a DS3231 RTC chip which is normally backed
by a battery or a supercapacitor to survive power failures. The DS3231 chip does
not contain the concept of a time zone. Therefore, I recommend that the
`DS3231TimeKeeper` class is used to store only the UTC date/time components,
instead of the local time. When the time is read back in using the
`DS3231TimeKeeper::getNow()`, you can convert that to the appropriate time zone
using the `DateTime::convertToTimeZone()` method.

```C++
DS3231TimeKeeper dsTimeKeeper;
...
void setup() {
  ...
  dsTimeKeeper.setup();
  ...

}
void loop() {
  ...
}
```

#### NTP Time Provider

The `NtpTimeProvider` is available on the ESP8266 and ESP32 have builtin WiFi
capability. This class uses an NTP client to fetch the current time from the
specified NTP server. The constructor takes 3 parameters which all of default
values so are optional.

You need to call the `setup()` with the `ssid` and `password` of the WiFi
connection. The method will time out after 5 seconds if the connection cannot
be established.

```C++
const char SSID[] = ...;
const char PASSWORD[] = ...;

NtpTimeProvider ntpTimeProvider;

void setup() {
  ...
  ntpTimeProvider.setup(SSID, PASSWORD);
  if (ntpTimeProvider.isSetup()) {
    Serial.println("WiFi connection failed... try again.");
  }
  ...
}

void loop() {
  ...
}
```
**Security Warning**: You should avoid committing your SSID and PASSWORD into a
public repository like GitHub because it will become public to anyone. Even if
you delete the commit, it will be accessible through the git history.

#### System Time Keeper

The `SystemTimeKeeper` is a special `TimeKeeper` that uses the Arduino built-in
`millis()` method as the source of its time. The biggest advantage of
`SystemTimeKeeper` is that its `getNow()` has very little overhead _(TBD: insert
benchmark)_ so it can be called as frequently as needed. The `getNow()` method
of other `TimeProviders` can consume a significant amount of time. For example,
the `DS3231TimeKeeper` must talk to the DS3231 RTC chip over an I2C bus. Even
worse, the `NtpTimeProvider` must the talk to the NTP server over the network
which can be unpredictably slow.

Unfortunately, the `millis()` internal clock of most (all?) Arduino boards is
not accurate. Therefore, the `SystemTimeKeeper` provides a mechanism to
synchronize its clock to an external (and presumably more accurate clock)
`TimeProvider`.

The `SystemTimeKeeper` also provides a way to save the current time to a
`backupTimeKeeper` (e.g. the `DS3231TimeKeeper` using an RTC chip with battery
backup). When the `SystemTimeKeeper` starts up, it will read the backup
`TimeKeeper` and set the current time. Then it can synchronize with an external
clock source (e.g. the `NtpTimeProvider`). The time is saved to the backup time
keeper whenever the `SystemTimeKeeper` is synced with the external time
provider.

Here is how to set up the `SystemTimeKeeper`:
```C++
DS3231TimeKeeper dsTimeKeeper;
NtpTimeProvider ntpTimeProvider(SSID, PASSWORD);
SystemTimeKeeper systemTimeKeeper(
  &ntpTimeProvider /*sync*/, &dsTimeKeeper /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  ntpTimeProvider.setup();
  systemTimeKeeper.setup();
  ...
}

void loop() {
}
```

If you wanted to use the `DS3231TimeKeeper` as *both* the backup and sync
time sources, then the setup would something like this:
```C++
DS3231TimeKeeper dsTimeKeeper;
SystemTimeKeeper systemTimeKeeper(
    &dsTimeKeeper /*sync*/, &dsTimeKeeper /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  systemTimeKeeper.setup();
  ...
}
```

You could also choose not to have either the backup or sync time sources, in
which case you can give `nullptr` as the correspond argument. For example,
to use no backup time keeper:
```C++
DS3231TimeKeeper dsTimeKeeper;
SystemTimeKeeper systemTimeKeeper(&dsTimeKeeper /*sync*/, nullptr /*backup*/);
...

void setup() {
  dsTimeKeeper.setup();
  systemTimeKeeper.setup();
  ...
}
```

#### System Clock Syncing and Heartbeat

For technical reasons &mdash; see the implementation of
`SystemTimeKeeper::getNow()`) &mdash; the `getNow()` method must be called
periodically to avoid an integer overflow. The maximum period between 2
consecutive calls to `getNow()` is 65.535 seconds. We need to implement a
"heartbeat" mechanism which simply calls the `getNow()` of the system time
keeper.

Secondly, since the internal `millis()` clock is not very accurate, we must
synchronize the system time keeper periodically. The frequency depends on the
accurate of the `millis()` and the cost of the call to the `getNow()` method of
the syncing time provider. For a DS3231 time source, syncing once every 1-10
minutes might work since talking to the RTC chip is cheap. For syncing with the
`NtpTimeProvider` with an accurate `millis()` maybe once every 1-12 hours might
be advisable.

The `SystemTimeKeeper` provides 2 ways to perform these periodic maintenance
actions. By default, the syncing happens every 3600 seconds, and the heartbeat
happens every 5 seconds. Those parameters are configurable in the constructors
of the following classes.

**Method 1: Using the Global Loop()**

You can use the `SystemTimeSyncLoop` and `SystemTimeHeartbeatLoop` classes and
insert them into the global `loop()` method:

```C++
SystemTimeKeeper systemTimeKeeper(...);
SystemTimeSyncLoop systemTimeSyncLoop(systemTimeKeeper);
SystemTimeHeartbeatLoop systemTimeHeartbeatLoop(systemTimeKeeper);

void loop() {
  systemTimeSyncLoop.loop();
  systemTimeHeartbeatLoop.loop();
}
```

**Method 2: Using AceRoutine Coroutines**

You can use 2 AceRoutine coroutines to perform the sync and heartbeat. First,
`#include <AceRoutine.h>` before the `<AceTime.h>` (to activate the
`SystemTimeSyncCoroutine` and `SystemTimeHeartbeatCoroutine` classes). Then
create the 2 coroutines, and configure it to run using the `CoroutineScheduler`:

```C++
#include <AceRoutine.h>
#include <AceTime.h>
...
SystemTimeKeeper systemTimeKeeper(...);
SystemTimeSyncCoroutine systemTimeSync(systemTimeKeeper);
SystemTimeHeartbeatCoroutine systemTimeHeartbeat(systemTimeKeeper);

void setup() {
  ...
  systemTimeSync.setupCoroutine(F("systemTimeSync"));
  systemTimeHeartbeat.setupCoroutine(F("systemTimeHeartbeat"));
  CoroutineScheduler::setup();
  ...
}

void loop() {
  CoroutineScheduler::loop();
  ...
}
```

The biggest advantage of using AceRoutine coroutines is that the syncing process
becomes non-blocking. In other words, if you are using the `NtpTimeProvider` to
provide syncing, the `SystemTimeSyncLoop` object calls its `getNow()` method,
which blocks the execution of the program until the NTP server returns a
response (or the request times out after 1000 milliseconds). If you use the
coroutines, the program continues to do other things (e.g. update displays, scan
for buttons) during the time that the `NtpTimeProvider` has issued a request and
is waiting for a response from the NTP server.

## System Requirements

This library was developed and tested using:

* [Arduino IDE 1.8.9](https://www.arduino.cc/en/Main/Software)
* [ESP8266 Arduino Core 2.5.1](https://github.com/esp8266/Arduino)
* [ESP32 Arduino Core 1.0.2](https://github.com/espressif/arduino-esp32)

I used Ubuntu 18.04 for most of my development.

The library is tested on the following hardware before each release:

* Arduino Nano clone (16 MHz ATmega328P)
* Arduino Pro Micro clone (16 MHz ATmega32U4)
* WeMos D1 Mini clone (ESP-12E module, 80 MHz ESP8266)
* ESP32 dev board (ESP-WROOM-32 module, 240 MHz dual core Tensilica LX6)

I will occasionally test on the following hardware as a sanity check:

* Teensy 3.2 (72 MHz ARM Cortex-M4)

## Benchmarks

### CPU

The [AutoBenchmark.ino](examples/AutoBenchmark/) program measures the
amount of CPU cycles taken by some of the more expensive `DateTime`
methods. The most expensive method is the `DateTime::forEpochSeconds(seconds)`
factory method. Here is a summary of how long that constructor takes for some
Arduino boards that I have access to:
```
----------------------------+---------+
Board or CPU                |  micros |
----------------------------+---------+
ATmega328P 16MHz (Nano)     | 401.800 |
ESP8266 80MHz               |  12.080 |
ESP32 240MHz                |   0.705 |
Teensy 3.2 96MHz            |   2.750 |
----------------------------+---------+
```

### Memory

Here is a quick summary of the amount of static RAM consumed by various
classes:

**8-bit processors**

```
sizeof(DateTime): 8
sizeof(TimeZone): 1
sizeof(TimePeriod): 4
sizeof(SystemTimeKeeper): 17
sizeof(DS3231TimeKeeper): 4
sizeof(SystemTimeSyncLoop): 14
sizeof(SystemTimeHeartbeatLoop): 8
sizeof(SystemTimeSyncCoroutine): 29
sizeof(SystemTimeHeartbeatCoroutine): 18
```

**32-bit processors**
```
sizeof(DateTime): 8
sizeof(TimeZone): 1
sizeof(TimePeriod): 4
sizeof(SystemTimeKeeper): 24
sizeof(DS3231TimeKeeper): 8
sizeof(NtpTimeProvider): 96 (ESP8266), 120 (ESP32)
sizeof(SystemTimeSyncLoop): 20
sizeof(SystemTimeHeartbeatLoop): 12
sizeof(SystemTimeSyncCoroutine): 52
sizeof(SystemTimeHeartbeatCoroutine): 36
```

### Comparison to Arduino Time Library

The [ComparisonBenchmark.ino](examples/ComparisonBenchmark/) program compares
the CPU time of AceTime methods with the equilvalent methods
[Arduino Time Library](https://github.com/PaulStoffregen/Time).
The functionality tested was the roundtrip conversion from `secondsFromEpoch` to
the date time components, then back to `secondsFromEpoch` again. Details are
given in the README.md file in that folder, but here is a summary for various
boards (all times in microseconds):
```
----------------------------+---------+----------+
Board or CPU                | AceTime | Time Lib |
----------------------------+---------+----------+
ATmega328P 16MHz (Nano)     | 364.000 |  879.000 |
ESP8266 80MHz               |  20.900 |   68.500 |
ESP32 240MHz                |   0.570 |    9.330 |
Teensy 3.2 96MHz            |   1.980 |   22.570 |
----------------------------+---------+---------+
```

## Bugs and Limitations

* AceTime uses an epoch of 2000-01-01T00:00:00Z.
  `OffsetDateTime::toEpochSeconds()` returns the number of seconds since the
  epoch as a 32-bit unsigned integer. So it will rollover just after
  2136-02-07T06:28:15Z. However, the largest `int32_t` value of `INT32_MAX` is
  used by `OffsetDateTime::kInvalidEpochSeconds` to indicate an invalid value.
  Therefore, the actual largest possible dateTime is one second before that,
  i.e. 2136-02-07T06:28:14Z.
* It is possible to construct a `DateTime` object with a `year` component
  greater than 136, but such an object may not be very useful because the
  `toSecondsSincEpoch()` method would return an incorrect number.
* The `NtpTimeProvider` on an ESP8266 calls `WiFi.hostByName()` to resolve
  the IP address of the NTP server. Unfortunately, this seems to be blocking
  call. When the DNS resolver is working properly, this call returns in ~10ms or
  less. But sometimes, the DNS resolver seems to get into a state where it takes
  4-5 **seconds** to time out. Even if you use coroutines, the entire program
  will block for those 4-5 seconds.
* [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) uses an epoch
  of 1900-01-01T00:00:00Z, with 32-bit unsigned integer as the seconds counter.
  It will overflow just after 2036-02-07T06:28:15Z.
* [Unix time](https://en.wikipedia.org/wiki/Unix_time) uses an epoch of
  1970-01-01T00:00:00Z. On 32-bit Unix systems that use a signed 32-bit integer
  to represent the seconds field, the unix time will rollover just after
  2038-01-19T03:14:07Z.

## Changelog

See [CHANGELOG.md](CHANGELOG.md).

## License

[MIT License](https://opensource.org/licenses/MIT)

## Feedback and Support

If you have any questions, comments, bug reports, or feature requests, please
file a GitHub ticket or send me an email. I'd love to hear about how this
software and its documentation can be improved. Instead of forking the
repository to modify or add a feature for your own projects, let me have a
chance to incorporate the change into the main repository so that your external
dependencies are simpler and so that others can benefit. I can't promise that I
will incorporate everything, but I will give your ideas serious considerationk

## Authors

Created by Brian T. Park (brian@xparks.net).
